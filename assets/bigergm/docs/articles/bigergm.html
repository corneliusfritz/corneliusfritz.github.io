<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="bigergm">
<title>An Introduction to Estimating Exponential Random Graph Models for Large Networks with `bigergm` • bigergm</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="An Introduction to Estimating Exponential Random Graph Models for Large Networks with `bigergm`">
<meta property="og:description" content="bigergm">
<meta property="og:image" content="/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">bigergm</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.1</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item">
  <a class="nav-link" href="../articles/bigergm.html">Get started</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav"></ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>An Introduction to Estimating Exponential Random Graph Models for Large Networks with `bigergm`</h1>
            
      
      
      <div class="d-none name"><code>bigergm.Rmd</code></div>
    </div>

    
    
<p>This vignette briefly introduces how to use the R package
<code>bigergm</code>, which estimates Hierarchical Exponential-Family
Random Graph Models <span class="citation">(HERGMs, Schweinberger and
Handcock 2015)</span>. The package <code>bigergm</code> builds on the R
packages <code>lighthergm</code> <span class="citation">(Martínez
Dahbura et al. 2021)</span> and <code>hergm</code> <span class="citation">(Schweinberger and Luna 2018)</span> and applies
scalable algorithms to scale the estimation up to big networks with up
to 50 K population members (see <span class="citation">Martínez Dahbura
et al. (2021)</span> and <span class="citation">Fritz et al.
(2024)</span>).</p>
<div class="section level2">
<h2 id="exponential-random-graph-models-for-large-networks">Exponential Random Graph Models for Large Networks<a class="anchor" aria-label="anchor" href="#exponential-random-graph-models-for-large-networks"></a>
</h2>
<p>Exponential Random Graph Models (ERGMs) are a popular class of models
for network data. They model the probability of observing a network as a
function of network statistics, such as the number of edges and
triangles. ERGMs are commonly employed in social network analysis but
have some limitations when applied to large networks. The main
limitation is that the likelihood function is intractable for large
networks, making it difficult to estimate the model parameters. At the
same time, larger networks warrant more complex models to capture the
underlying structure of the network.</p>
<p>To address these limitations, <code>bigergm</code> implements a
scalable algorithm for estimating HERGMs, which generalize ERGMs that
allow for local dependence induced by non-overlapping blocks of nodes
with network data. Introduced by <span class="citation">Schweinberger
and Handcock (2015)</span>, complex dependence is allowed only between
nodes within the same block. Thereby, we obtain a more flexible model
that can capture the cohesive subgroups in the network globally while
accounting for dependence within these subgroups on the local level.</p>
<div class="section level3">
<h3 id="model-specification">Model Specification<a class="anchor" aria-label="anchor" href="#model-specification"></a>
</h3>
<p>Consider a network of <span class="math inline">\(N\)</span>
population members encompassed in the set <span class="math inline">\(\mathcal{P} = \{1, \ldots, N\}\)</span>. Define
the adjacency matrix corresponding to this network as <span class="math inline">\(\mathbf{Y}= (Y_{i,j}) \in \mathbb{R}^{N\times
N}\)</span>, where <span class="math inline">\(Y_{i,j}\)</span> is the
entry in the <span class="math inline">\(i\)</span>-th row and <span class="math inline">\(j\)</span>-th column of the matrix. If <span class="math inline">\(Y_{i,j} = 1\)</span>, nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are connected; otherwise, they are not
connected. In this vignette we only regard undirected networks, thus the
adjacency matrix is symmetric, i.e., <span class="math inline">\(Y_{i,j}
= Y_{j, i}\)</span>.<br>
Note, however, that the package <code>bigergm</code> also supports
directed networks. The number of blocks is denoted as <span class="math inline">\(K\)</span> and <span class="math inline">\(\mathbf{z}= (z_{i,k}) \in \mathbb{R}^{N\times
K}\)</span> is the block membership matrix with entries <span class="math inline">\(z_{i,k}\)</span> equal to 1 if node <span class="math inline">\(i\)</span> belongs to block <span class="math inline">\(k\)</span> and 0 otherwise. Let <span class="math inline">\(\mathbf{Y}_{k,l}\)</span> be the submatrix of
<span class="math inline">\(\mathbf{Y}\)</span> of the connections
between blocks <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span>, i.e., the matrix including the
connections between population members <span class="math inline">\(i\)</span> and <span class="math inline">\(j \in
\mathcal{P}\)</span> with <span class="math inline">\(z_{i,k} = z_{j,l}=
1\)</span>. The submatrix <span class="math inline">\(\mathbf{Y}_{k,k}\)</span> of <span class="math inline">\(\mathbf{Y}\)</span> contains the connections
within block <span class="math inline">\(k\)</span>, i.e., the matrix
including the connections between population members <span class="math inline">\(i\)</span> and <span class="math inline">\(j \in
\mathcal{P}\)</span> with <span class="math inline">\(z_{i,k} = z_{j,k}=
1\)</span>. Let <span class="math inline">\(\mathbf{x} = (x_{i,p}) \in
\mathbb{R}^{N\times p}\)</span> be a matrix of nodal covariates, where
<span class="math inline">\(p\)</span> is the number of covariates and
<span class="math inline">\(x_{i,p}\)</span> refers to the <span class="math inline">\(p\)</span>th nodal covariate of population member
<span class="math inline">\(i\)</span>. For the context of
<code>bigergm</code>, assume that all nodal covariates are categorical.
Generally, we refer to random variables by capitalized letters and their
realizations by lowercase letters.</p>
<p>Given this notation, the probability of observing the network <span class="math inline">\(\mathbf{Y}\)</span> for a given the block
membership matrix <span class="math inline">\(\mathbf{Z}\)</span> is
given by: <span class="math display">\[
\mathbf{P}_\theta(\mathbf{Y} = \mathbf{y} | \mathbf{Z} =
\mathbf{z},\mathbf{X} = \mathbf{x}) = \prod_{k \neq l}
\mathbf{P}_{\alpha}(\mathbf{Y}_{k,l} | \mathbf{Z} = \mathbf{z},
\mathbf{X} = \mathbf{x}) \prod_{k} \mathbf{P}_{\beta}(\mathbf{Y}_{k,k} |
\mathbf{Z} = \mathbf{z}, \mathbf{X} = \mathbf{x}),
\]</span> where <span class="math inline">\(\mathbf{P}_{\alpha}(\mathbf{Y}_{k,l} | \mathbf{Z}
= \mathbf{z})\)</span> is the probability of observing the edges between
blocks <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span> given <span class="math inline">\(\mathbf{z}\)</span> and <span class="math inline">\(\mathbf{P}_{\beta}(\mathbf{Y}_{k,k} | \mathbf{Z} =
\mathbf{z})\)</span> is the probability of observing the edges within
block <span class="math inline">\(k\)</span> given <span class="math inline">\(\mathbf{z}\)</span>. The parameter vectors <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are the coefficients of the
between-block and within-block networks, respectively. How these two
models are specified is sketched in the next two paragraphs.</p>
<div class="section level4">
<h4 id="between-block-model">Between-block Model<a class="anchor" aria-label="anchor" href="#between-block-model"></a>
</h4>
<p>For the probability model for edges between population members of
blocks <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span>, we employ a network model assuming
dyadic independence between the edges:</p>
<p><span class="math display">\[
\mathbf{P}_{\alpha}(\mathbf{Y}_{k,l} = \mathbf{y}_{k,l} | \mathbf{Z} =
\mathbf{z}, \mathbf{X} = \mathbf{x})  = \prod_{(i,j) \text{; } z_{ik} =
1 \text{, } z_{jl} = 1} \mathbf{P}_{\alpha}(Y_{i,j}  = y_{i,j} |
\mathbf{Z} = \mathbf{z}, \mathbf{X} = \mathbf{x}),
\]</span> where <span class="math display">\[
\mathbf{P}_{\alpha}(Y_{i,j} = y_{i,j} | \mathbf{Z} = \mathbf{z},
\mathbf{X} = \mathbf{x}) = (\pi_{k,l}(\alpha, \mathbf{x}))^{y_{i,j}} (1
- \pi_{k,l}(\alpha, \mathbf{x}))^{1 - y_{i,j}}
\]</span> is the probability distribution of a Bernoulli distribution
with parameter <span class="math inline">\(\pi_{k,l}(\alpha,
\mathbf{x})\)</span> evaluated at <span class="math inline">\(y_{i,j}\)</span>.<br>
The parameter <span class="math inline">\(\pi_{k,l}(\alpha,
\mathbf{x})\)</span> is the probability of observing an edge between
nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> with <span class="math inline">\(z_{i,k} = z_{j,l} = 1\)</span> and have different
forms:</p>
<ul>
<li>For the standard Stochastic Block Model (SBM), the probability of
observing an edge between nodes <span class="math inline">\(i\)</span>
and <span class="math inline">\(j\)</span> is given by <span class="math inline">\(\alpha_{k,l}\)</span>.</li>
<li>Extending this simplistic model, the current implementation allows
the usage of <code>nodematch</code> statistics to include the nodal
covariates <span class="math inline">\(\mathbf x\)</span> in the model,
implying the following probability for <span class="math inline">\(y_{i,j}\)</span> with <span class="math inline">\(z_{i,k} = z_{j,l} = 1\)</span>:</li>
</ul>
<p><span class="math display">\[
\pi_{k,l}(\alpha, \mathbf{x}) = \text{logit}^{-1}\left(\alpha + \sum_{p
= 1}^P \alpha_p \, \mathbb{I}\left(x_{i,p} = x_{j,p}\right) \right),
\]</span> where all parameters (<span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\alpha_p\)</span> for <span class="math inline">\(p = 1, \ldots, P\)</span>) can vary for each pair
of blocks <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span>.</p>
</div>
<div class="section level4">
<h4 id="within-block-model">Within-block Model<a class="anchor" aria-label="anchor" href="#within-block-model"></a>
</h4>
<p>The probability of observing the edges within block <span class="math inline">\(k\)</span> is modeled as a function of network
statistics, such as the number of edges or triangles within block <span class="math inline">\(k\)</span>. We specify the within-block networks
as exponential-family random graph models: <span class="math display">\[
\mathbf{P}_{\beta}(\mathbf{Y}_{k,k} = \mathbf{y}_{k,k} | \mathbf{Z} =
\mathbf{z}, \mathbf{X} = \mathbf{x}) = \exp\left(\beta^\top
\mathbf{s}(\mathbf{y}_{k,k}, \mathbf{x})\right)/ c(\beta, \mathbf{z},
\mathbf{x}),
\]</span> where <span class="math inline">\(\mathbf{s}(\mathbf{y}_{k,k},
\mathbf{x})\)</span> is a vector of sufficient statistics counting,
e.g., the edges within block <span class="math inline">\(k\)</span> and
<span class="math inline">\(c(\beta, \mathbf{z}, \mathbf{x})\)</span> is
a normalizing constant guaranteeing that the probability distribution
sums to one. Examples of network statistics include the number of edges,
triangles, and degree statistics (see <span class="citation">Morris,
Handcock, and Hunter (2008)</span> and all references therein).</p>
</div>
</div>
<div class="section level3">
<h3 id="estimation">Estimation<a class="anchor" aria-label="anchor" href="#estimation"></a>
</h3>
<p>Since the block membership matrix <span class="math inline">\(\mathbf{z}\)</span> is usually unobserved, we
estimate it. Therefore, we assume that the now random block membership
matrix <span class="math inline">\(\mathbf{Z}\)</span> is a latent
variable and following a multinomial distribution: <span class="math display">\[
\mathbf{Z} \sim \text{Multinomial}(1; \gamma_1, \ldots, \gamma_K),
\]</span> where <span class="math inline">\(\gamma_k\)</span> is the
marginal probability that a node belongs to block <span class="math inline">\(k\)</span> for <span class="math inline">\(k = 1,
\ldots, K\)</span>. Given this context, the model is estimated in two
steps by the algorithm proposed by <span class="citation">Babkin,
Stewart, and Schweinberger (2020)</span>:</p>
<ol style="list-style-type: decimal">
<li>Recover the block membership matrix <span class="math inline">\(\mathbf{Z}\)</span> by maximizing a lower bound of
the likelihood from the observed network <span class="math inline">\(\mathbf{Y}\)</span> (see <span class="citation">Babkin, Stewart, and Schweinberger (2020)</span> and
<span class="citation">Vu, Hunter, and Schweinberger (2013)</span> for
details).</li>
<li>Given the estimated block membership matrix <span class="math inline">\(\hat{\mathbf{Z}}\)</span>, estimate the
coefficients <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> by maximizing the pseudo-likelihood
of the observed network <span class="math inline">\(\mathbf{Y}\)</span>.
The pseudo-likelihood of the observed network <span class="math inline">\(\mathbf{Y}\)</span> given the estimated block
membership matrix <span class="math inline">\(\hat{\mathbf{Z}}\)</span>
is equivalent to the likelihood of a logistic regression model and can,
therefore, be estimated by standard optimization algorithms. For this
step, the entire computational machinery implemented in the
<code>ergm</code> package is used.</li>
</ol>
<p>However, note that the first step is unnecessary if the block
membership matrix is known.</p>
<p>The package <code>bigergm</code> implements a scalable algorithm for
estimating HERGMs even for large networks by exploiting the structure of
the model and the network data (details are provided in <span class="citation">Martínez Dahbura et al. (2021)</span> and <span class="citation">Fritz et al. (2024)</span>).</p>
</div>
</div>
<div class="section level2">
<h2 id="installation">Installation<a class="anchor" aria-label="anchor" href="#installation"></a>
</h2>
<p>You can install the CRAN version of <code>bigergm</code> by running
the following command:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html" class="external-link">install.packages</a></span><span class="op">(</span><span class="st">"bigergm"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="a-simple-example">A simple example<a class="anchor" aria-label="anchor" href="#a-simple-example"></a>
</h2>
<p>Let’s start with a simple example using the toy network included in
the package. The toy network is a small network with a clear community
structure, which is helpful for testing the package.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Load the network object.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">toyNet</span><span class="op">)</span></span>
<span><span class="co"># Plot the network.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">toyNet</span>, vertex.col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"tomato"</span>, <span class="st">"steelblue"</span>, <span class="st">"darkgreen"</span>, <span class="st">"black"</span><span class="op">)</span>,</span>
<span>                        each <span class="op">=</span> <span class="va">toyNet</span><span class="op">$</span><span class="va">gal</span><span class="op">$</span><span class="va">n</span><span class="op">/</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-3-1.png" width="100%"></p>
<p>It is visible that this network has a cluster or community structure.
Although this is an artificial network, we often observe such community
structures in real-world social networks. Exploiting this stylized fact,
we model the way population members in a network get connected
differently for connections across and within communities:</p>
<ul>
<li>Connections across communities happen by luck, influenced by
homophily</li>
<li>Connections within communities also consider interdependencies among
links. For example, the probability that population members <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> get connected may be influenced by a
third population member <span class="math inline">\(k\)</span>.</li>
</ul>
<p>To estimate an Exponential Random Graph model with local dependence,
we first need to specify the model formula that specifies the model. As
described in the previous section, the model consists of two parts: the
between-block model and the within-block model. To ease this step, both
parts are specified in one formula very similar to specifying a model in
<code><a href="https://rdrr.io/pkg/ergm/man/ergm.html" class="external-link">ergm::ergm()</a></code>. All terms that induce dependence are excluded
from the between block model, while the within block model includes all
terms. In the following example, we include the number of edges, the
number of triangles, and nodematch statistics for the nodal covariates
<code>x</code> and <code>y</code> in the model.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model_formula</span> <span class="op">&lt;-</span> <span class="va">toyNet</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="fu">nodematch</span><span class="op">(</span><span class="st">"x"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">nodematch</span><span class="op">(</span><span class="st">"y"</span><span class="op">)</span> <span class="op">+</span> <span class="va">triangle</span></span></code></pre></div>
<p>Assuming that covariate ‘x’ is the first and covariate ‘y’ is the
second covariate, the probability of observing <span class="math inline">\(Y_{i,j}\)</span> with <span class="math inline">\(z_{i,k} = z_{j,l} = 1\)</span> is specified by:
<span class="math display">\[
\pi_{k,l}(\alpha, \mathbf{x}) = \text{logit}^{-1}\left(\alpha_0 +
\alpha_{2}\, \mathbb{I}(x_{i,1} = x_{j,1}) + \alpha_2\,
\mathbb{I}(x_{i,2} = x_{j,2})\right)
\]</span> and the sufficient statistics of the within-block model are:
<span class="math display">\[
\mathbf{s}(\mathbf{y}_{k,k}, \mathbf{x}) = \left(\sum_{i&lt;j} y_{i,j},
\sum_{i&lt;j} \mathbb{I}(x_{1,i} = x_{1,j})\, y_{i,j}, \sum_{i&lt;j}
\mathbb{I}(x_{1,i} = x_{1,j})\, y_{i,j}, \sum_{i&lt;j}\sum_{h \neq i,j}
y_{i,j}\, y_{i,h}\, y_{h,j}\right).
\]</span></p>
<p>We can estimate the specified model with the <code><a href="../reference/bigergm.html">bigergm()</a></code>
function, which takes the following parameters:</p>
<ul>
<li><p><code>object</code>: A formula specifying the model to estimate
(as detailed in the previous paragraph). See <code><a href="../reference/bigergm.html">help(bigergm)</a></code>
for how providing a fitted <code>bigergm</code> object can be used to
continue the estimation.</p></li>
<li><p><code>clustering_with_features</code>: boolean value set to TRUE,
if the algorithm should consider nodal covariates in the first step of
the estimation.</p></li>
<li><p><code>n_blocks</code>: Number of blocks to recover (in the above
explanations, <span class="math inline">\(K\)</span>).</p></li>
<li><p><code>n_MM_step_max</code>: Maximum number of MM algorithm
steps.</p></li>
<li><p><code>tol_MM_step</code>: Threshhold when convergence is reached.
Following <span class="citation">Vu, Hunter, and Schweinberger
(2013)</span>, we stop the algorithm when the relative change in the
lower bound of the objective function is less than
<code>tol_MM_step</code>.</p></li>
<li><p><code>estimate_parameters</code>: boolean value set to TRUE, if
the algorithm should estimate the parameters after the block recovery
step.</p></li>
<li><p><code>check_block_membership</code>: boolean value set to TRUE,
if the algorithm should keep track of block memberships at each MM
iteration.</p></li>
</ul>
<p>There are other parameters that you can specify, which are detailed
in the documentation (see <code><a href="../reference/bigergm.html">help(bigergm)</a></code>).</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res</span> <span class="op">&lt;-</span><span class="fu"><a href="../reference/bigergm.html">bigergm</a></span><span class="op">(</span></span>
<span>    <span class="co"># The model you would like to estimate</span></span>
<span>    object <span class="op">=</span> <span class="va">model_formula</span>,</span>
<span>    <span class="co"># The number of blocks</span></span>
<span>    n_blocks <span class="op">=</span>  <span class="fl">4</span>, </span>
<span>    <span class="co"># The maximum number of MM algorithm steps</span></span>
<span>    n_MM_step_max <span class="op">=</span> <span class="fl">100</span>,</span>
<span>    <span class="co"># The tolarence for the MM algorithm</span></span>
<span>    tol_MM_step <span class="op">=</span> <span class="fl">1e-6</span>,</span>
<span>    <span class="co"># Perform parameter estimation after the block recovery step</span></span>
<span>    estimate_parameters <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    <span class="co"># Indicate that clustering must take into account nodematch on characteristics</span></span>
<span>    clustering_with_features <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    <span class="co"># Keep track of block memberships at each EM iteration</span></span>
<span>    check_block_membership <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>    <span class="co"># Name the heuristic algorithm used for initializing the block memberships</span></span>
<span>    initialization <span class="op">=</span> <span class="st">"walktrap"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>We can plot the estimated the objective function of the first
estimation step recovering the latent community structure over
iterations. This allows us to check whether this step has converged.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">MM_lower_bound</span><span class="op">)</span>,</span>
<span>     <span class="va">res</span><span class="op">$</span><span class="va">MM_lower_bound</span>, type <span class="op">=</span> <span class="st">"l"</span>, xlab <span class="op">=</span> <span class="st">"Iterations"</span>, ylab <span class="op">=</span> <span class="st">"Lower Bound"</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-6-1.png" width="100%"></p>
<p>The result indicates that the clustering step converged at the early
stage. Note that the number of iterations you need to perform
(<code>n_MM_step_max</code>) varies depending on the network’s size and
clarity in community structure. The convergence of the lower bound does,
however, not guarantee the convergence of the clustering step to a
unique maximizer. Therefore, restarting the algorithm with different
initializations may be advisable in practice.</p>
<p>You can check the clustering result by plotting the network with
nodes colored by the estimated block membership. The edges are grey if
the two population members are from different blocks and black
otherwise.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-7-1.png" width="100%"></p>
<p>The parameter estimates of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> may be inspected using the
<code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> function.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># For the between networks</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">est_between</span><span class="op">)</span></span>
<span><span class="co">#&gt;  Results:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;             Estimate Std. Error MCMC % z value Pr(&gt;|z|)    </span></span>
<span><span class="co">#&gt; edges       -4.21749    0.07482      0 -56.369   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; nodematch.x  0.78273    0.16144      0   4.848   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; nodematch.y  0.38854    0.18433      0   2.108    0.035 *  </span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Warning:  The standard errors are based on naive pseudolikelihood and are suspect. Set control.ergm$MPLE.covariance.method='Godambe' for a simulation-based approximation of the standard errors.</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;      Null Pseudo-deviance: 2576  on 8  degrees of freedom</span></span>
<span><span class="co">#&gt;  Residual Pseudo-deviance: 2551  on 5  degrees of freedom</span></span>
<span><span class="co">#&gt;  </span></span>
<span><span class="co">#&gt; AIC: 2557  BIC: 2558  (Smaller is better. MC Std. Err. = NA)</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># For the within networks</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">est_within</span><span class="op">)</span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; ergm::ergm(formula = within_formula, offset.coef = offset.coef, </span></span>
<span><span class="co">#&gt;     estimate = method, control = control)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Maximum Pseudolikelihood Results:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;             Estimate Std. Error MCMC % z value Pr(&gt;|z|)    </span></span>
<span><span class="co">#&gt; edges       -1.80056    0.06660      0 -27.036   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; nodematch.x  0.86683    0.10351      0   8.375   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; nodematch.y  0.96478    0.10368      0   9.305   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; triangle     0.14615    0.01744      0   8.382   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Warning:  The standard errors are based on naive pseudolikelihood and are suspect. Set control.ergm$MPLE.covariance.method='Godambe' for a simulation-based approximation of the standard errors.</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;      Null Pseudo-deviance: 6793  on 4900  degrees of freedom</span></span>
<span><span class="co">#&gt;  Residual Pseudo-deviance: 5154  on 4896  degrees of freedom</span></span>
<span><span class="co">#&gt;  </span></span>
<span><span class="co">#&gt; AIC: 5162  BIC: 5188  (Smaller is better. MC Std. Err. = 0)</span></span></code></pre></div>
<p>Currently, only <code>nodematch()</code> terms are supported as a way
to include covariates in the model.</p>
</div>
<div class="section level2">
<h2 id="simulation">Simulation<a class="anchor" aria-label="anchor" href="#simulation"></a>
</h2>
<p>You can simulate networks with local dependence by using
<code><a href="../reference/bigergm.html">bigergm ()</a></code> and <code><a href="../reference/simulate_bigergm.html">simulate_bigergm()</a></code> functions.
The <code><a href="../reference/simulate.bigergm.html">simulate.bigergm()</a></code> function is a wrapper around the
<code><a href="../reference/simulate_bigergm.html">simulate_bigergm()</a></code> function for a particular fitted
<code>bigergm</code> object. To apply the
<code><a href="../reference/simulate.bigergm.html">simulate.bigergm()</a></code> function, you only need to provide the
fitted <code>bigergm</code> object.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">res</span>, seed <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt;  Network attributes:</span></span>
<span><span class="co">#&gt;   vertices = 200 </span></span>
<span><span class="co">#&gt;   directed = FALSE </span></span>
<span><span class="co">#&gt;   hyper = FALSE </span></span>
<span><span class="co">#&gt;   loops = FALSE </span></span>
<span><span class="co">#&gt;   multiple = FALSE </span></span>
<span><span class="co">#&gt;   bipartite = FALSE </span></span>
<span><span class="co">#&gt;   total edges= 1464 </span></span>
<span><span class="co">#&gt;     missing edges= 0 </span></span>
<span><span class="co">#&gt;     non-missing edges= 1464 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  Vertex attribute names: </span></span>
<span><span class="co">#&gt;     block vertex.names x y </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  Edge attribute names not shown</span></span></code></pre></div>
<p>The <code><a href="../reference/simulate_bigergm.html">simulate_bigergm()</a></code> function allows you to simulate
networks with local dependence from scratch. The function requires
coefficients for the between and within connections, the formula for the
model, the number of simulations to return, and the output format.
Depending on the output format, the function returns a list with the
network statistics for the between and within connections, the adjacency
matrix of the simulated network, or the network object itself.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim_net</span> <span class="op">&lt;-</span> <span class="fu">bigergm</span><span class="fu">::</span><span class="fu"><a href="../reference/simulate_bigergm.html">simulate_bigergm</a></span><span class="op">(</span></span>
<span>  formula <span class="op">=</span> <span class="va">model_formula</span>,</span>
<span>  <span class="co"># The coefficients for the between connections</span></span>
<span>  coef_between <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">est_between</span><span class="op">$</span><span class="va">coefficients</span>,</span>
<span>   <span class="co"># The coefficients for the within connections</span></span>
<span>  coef_within <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">est_within</span><span class="op">$</span><span class="va">coefficients</span>,</span>
<span>  <span class="co"># Number of simulations to return</span></span>
<span>  nsim <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  <span class="co"># If `stats` a list with network statistics </span></span>
<span>  <span class="co"># for the between and within connections is returned</span></span>
<span>  output <span class="op">=</span> <span class="st">"network"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>After simulating the network, you can plot it to assess whether the
community structure is preserved.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">sim_net</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-12-1.png" width="100%"></p>
</div>
<div class="section level2">
<h2 id="goodness-of-fit">Goodness-of-fit<a class="anchor" aria-label="anchor" href="#goodness-of-fit"></a>
</h2>
<p>Following the estimation, consider evaluating the goodness-of-fit of
the model. In line with the ERGM literature, we provide a
goodness-of-fit assessment that evaluates how good simulations from the
model fit the observed network. We provide a function <code>gof()</code>
to carry out this task:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">gof_res</span> <span class="op">&lt;-</span> <span class="fu">gof</span><span class="op">(</span></span>
<span>  <span class="co"># The object returned by bigergm::bigergm()</span></span>
<span>  object <span class="op">=</span> <span class="va">res</span>,</span>
<span>  <span class="co"># The number of simulations to use</span></span>
<span>  nsim <span class="op">=</span> <span class="fl">100</span>, </span>
<span>  <span class="co"># Compute the geodesic distance for the observed and each simulated network</span></span>
<span>  compute_geodesic_distance <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  <span class="co"># Set a seed for reproducibility</span></span>
<span>  seed <span class="op">=</span> <span class="fl">1234</span>,</span>
<span>  <span class="co"># Start at the observed network</span></span>
<span>  start_from_observed <span class="op">=</span> <span class="cn">TRUE</span>, type <span class="op">=</span> <span class="st">"within"</span>,</span>
<span>  <span class="co"># The control parameters for the simulation</span></span>
<span>  control_within <span class="op">=</span> <span class="fu">ergm</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/ergm/man/control.simulate.ergm.html" class="external-link">control.simulate.formula</a></span><span class="op">(</span>MCMC.burnin <span class="op">=</span> <span class="fl">1000</span>, MCMC.interval <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The parameter <code>control_within</code> is used to control the MCMC
simulation carried out to simulate from the model. For details we refer
to <code>help(ergm::control.simulate.formula)</code>. The function
evaluates the following metrics for a hundred simulated and observed
networks:</p>
<ol style="list-style-type: decimal">
<li><p>network statistics used in the fit or formula provided,</p></li>
<li><p>normalized network statistics (the network statistics normalized
around the observed statistics),</p></li>
<li><p>degree distribution,</p></li>
<li><p>geodesic distance, and</p></li>
<li><p>edgewise shared partners.</p></li>
</ol>
<p>The function <code>bigergm::gof_bigergm()</code> returns a list of
data frames for these matrices, allowing you to create plots that match
your needs flexibly. Below is an example plot for the degree
distribution on the log scale.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">degree_gof</span> <span class="op">&lt;-</span> </span>
<span>  <span class="va">gof_res</span><span class="op">$</span><span class="va">simulated</span><span class="op">$</span><span class="va">degree_dist</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html" class="external-link">group_by</a></span><span class="op">(</span><span class="va">degree</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html" class="external-link">summarise</a></span><span class="op">(</span>log_mean_share <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">share</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                   log_sd_share <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html" class="external-link">sd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">share</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html" class="external-link">ungroup</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">degree_gof</span><span class="op">$</span><span class="va">degree</span>, <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_mean_share</span>,</span>
<span>     xlab <span class="op">=</span> <span class="st">"Degree"</span>, ylab <span class="op">=</span> <span class="st">"Log Prop. of Nodes"</span>,</span>
<span>     ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">5.5</span>,<span class="op">-</span><span class="fl">1.8</span><span class="op">)</span>, xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">6</span>,<span class="fl">17</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"l"</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">degree_gof</span><span class="op">$</span><span class="va">degree</span>, <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_mean_share</span><span class="op">+</span> <span class="fl">1.96</span> <span class="op">*</span> <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_sd_share</span>, type <span class="op">=</span> <span class="st">"l"</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">degree_gof</span><span class="op">$</span><span class="va">degree</span>, <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_mean_share</span><span class="op">-</span> <span class="fl">1.96</span> <span class="op">*</span> <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_sd_share</span>, type <span class="op">=</span> <span class="st">"l"</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">tmp_info</span> <span class="op">&lt;-</span> <span class="va">gof_res</span><span class="op">$</span><span class="va">original</span><span class="op">$</span><span class="va">degree_dist</span> <span class="op">%&gt;%</span> </span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">share</span> <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">&amp;</span> <span class="va">degree</span> <span class="op">&lt;</span> <span class="fl">22</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">tmp_info</span><span class="op">$</span><span class="va">degree</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">tmp_info</span><span class="op">$</span><span class="va">share</span><span class="op">)</span>, lty <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-14-1.png" width="100%"></p>
<p>Alternatively, you can use the <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> function to
visualize the goodness-of-fit results. Three plots are generated
checking whether the estimated model can adequately capture the degree
distribution, edgewise-shared partner distribution, and geodesic
distances of the observed network. In a fourth plot, the simulated
network statistics are plotted normalized around the observed
statistics. For a good fit, all values should be around zero. In all
plots, the red line represents the observed network, and the boxplot
represents the simulated networks.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">gof_res</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-15-1.png" width="100%"><img src="bigergm_files/figure-html/unnamed-chunk-15-2.png" width="100%"><img src="bigergm_files/figure-html/unnamed-chunk-15-3.png" width="100%"><img src="bigergm_files/figure-html/unnamed-chunk-15-4.png" width="100%"></p>
</div>
<div class="section level2">
<h2 id="when-you-work-with-large-networks">When you work with large networks<a class="anchor" aria-label="anchor" href="#when-you-work-with-large-networks"></a>
</h2>
<p>If you would like to estimate an bigergm with a large network (say,
when the number of nodes <span class="math inline">\(\geq\)</span>
50,000):</p>
<ul>
<li>Select features sparse enough to fit into memory. Covariates such as
gender or race will be too dense to construct feature matrices. This is
a non-negligible limitation of our algorithm and will be solved in the
future.</li>
<li>Use Python’s infomap to initialize clusters. This is because it is
much faster to implement cluster initialization than R functions such as
<code><a href="https://r.igraph.org/reference/cluster_infomap.html" class="external-link">igraph::cluster_infomap()</a></code>. Set
<code>use_infomap_python = TRUE</code> in
<code><a href="../reference/bigergm.html">bigergm::bigergm()</a></code>.</li>
<li>When the MM estimation does not seem to have converged by inspecting
the lower bound plot, you can further continue iterating by passing the
<code>bigergm</code> class object to <code><a href="../reference/bigergm.html">bigergm::bigergm()</a></code> as
follows (all parameters such as the number of MM iterations will be
inherited from the previous estimation unless specified).</li>
<li>You can also set the parameter
<code>only_use_preprocessed = TRUE</code>, if you do not want to
preprocess it again and start the estimation again from a different
initial value.</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_second</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">bigergm</span><span class="fu">::</span><span class="fu"><a href="../reference/bigergm.html">bigergm</a></span><span class="op">(</span>object <span class="op">=</span> <span class="va">res</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-babkin_2020" class="csl-entry">
Babkin, Sergii, Jonathan Stewart, and Michael Schweinberger. 2020.
<span>“Large-Scale Estimation of Random Graph Models with Local
Dependence.”</span> <em>Computational Statistics &amp; Data
Analysis</em> 152: 107029.
</div>
<div id="ref-fritz2024" class="csl-entry">
Fritz, Cornelius, Co-Piere Georg, Angelo Mele, and Michael
Schweinberger. 2024. <span>“A Strategic Model of Software Dependency
Networks,”</span> Working Paper. Available at
https://arxiv.org/abs/2402.13375.
</div>
<div id="ref-martinezdahbura2021" class="csl-entry">
Martínez Dahbura, Juan Nelson, Shota Komatsu, Takanori Nishida, and
Angelo Mele. 2021. <span>“A Structural Model of Business Card Exchange
Networks,”</span> Working Paper. Available at
https://arxiv.org/abs/2105.12704.
</div>
<div id="ref-morris2008" class="csl-entry">
Morris, Martina, Mark S Handcock, and Dave Hunter. 2008.
<span>“Specification of Exponential-Family Random Graph Models: Terms
and Computational Aspects.”</span> <em>Journal of Statistical
Software</em> 24 (4).
</div>
<div id="ref-schweinberger2015" class="csl-entry">
Schweinberger, Michael, and Mark S Handcock. 2015. <span>“Local
Dependence in Random Graph Models: Characterization, Properties and
Statistical Inference.”</span> <em>Journal of the Royal Statistical
Society B</em> 77 (3): 647–76.
</div>
<div id="ref-schweinberger2018" class="csl-entry">
Schweinberger, Michael, and Pamela Luna. 2018. <span>“Hergm:
Hierarchical Exponential-Family Random Graph Models.”</span> <em>Journal
of Statistical Software</em> 85 (1): 1–39.
</div>
<div id="ref-vu_2013" class="csl-entry">
Vu, Duy, David Hunter, and Michael Schweinberger. 2013.
<span>“Model-Based Clustering of Large Networks.”</span> <em>The Annals
of Applied Statistics</em> 7 (2): 1010–39.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Cornelius Fritz, Shota Komatsu, Juan Nelson Martínez Dahbura, Takanori Nishida, Angelo Mele, Michael Schweinberger.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
