<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: css | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/css/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2021-10-06T21:47:56+02:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CSS is Hard and Other Things I Learned Working on the 2019 Artsy Vanguard]]></title>
    <link href="https://artsy.github.io/blog/2019/10/29/css-is-hard-and-vanguard-2019-learnings/"/>
    <updated>2019-10-29T00:00:00+01:00</updated>
    <id>https://artsy.github.io/blog/2019/10/29/css-is-hard-and-vanguard-2019-learnings</id>
    <content type="html"><![CDATA[<p>The Artsy Vanguard is an annual editorial series where we feature up-and-coming, notable, and praiseworthy artists
and their contributions to the art world. 2019 was the second year that Artsy published this special feature,
although we have been publishing custom editorial segments multiple times per year since 2015.</p>

<p><em>In this post, I’ll discuss my recent experience working on the
<a href="https://www.artsy.net/series/artsy-vanguard-2019">2019 Artsy Vanguard</a> editorial feature. I’ll start by
introducing the technology stack behind our articles and then discuss what I learned from both a team/organization
and technical perspective.</em></p>

<!-- more -->


<a name="An.Introduction.to.Artsy.Editorial"></a>
<h1>An Introduction to Artsy Editorial</h1>

<p>Typically our editorial works fall under one of five or so categories:</p>

<ul>
<li><a href="https://www.artsy.net/article/artsy-editorial-hip-hop-legend-q-tip-shares-diverse-art-collection">Standard articles</a>,
which have the same layout, but whose content could broadly relate to any of the primary categories Artsy’s
editors tend to cover.</li>
<li><a href="https://www.artsy.net/news">News content</a> consisting of an infinitely scrolling feed of the latest newsworthy
events in the art world.</li>
<li><a href="https://www.artsy.net/series/artsy-editors-future-art">Sponsored</a> and non-sponsored editorial features that may
be a <a href="https://www.artsy.net/article/artsy-editorial-rise-fall-internet-art-communities">standalone</a> publication
or a <a href="https://www.artsy.net/series/how-to-be-an-artist">part of a larger related series</a> of features.</li>
<li><a href="https://www.artsy.net/series/artsy-editors-future-art-carrie-mae-weems">Video editorial series</a>.</li>
</ul>


<p>For more information on Artsy's editorals, check out this
<a href="https://artsy.github.io/blog/2019/03/05/custom-editorial-features/">blog post</a> written by Senior Software Engineer
<a href="https://artsy.github.io/author/eve/">Eve Essex</a>.</p>

<p>To maintain consistency and standardization in terms of user experience design, layout, and page interactivity
options of the editorials that we offer, we use an internal content management service.
<a href="http://pages.artsy.net/rs/609-FDY-207/images/Gallery%20Guide%20to%20Artsy%20Writer.pdf">Artsy Writer</a> enables our
editorial team to publish content to the main Artsy website without having to collaborate with our engineering
organization. (Yay software!) Given that it is designed to handle the layout of the different types of editorial
features that we offer in a uniform way, highly customized editorials like the
<a href="https://www.artsy.net/series/artsy-vanguard-2019">2019 Artsy Vanguard</a> or
<a href="https://www.artsy.net/article/artsy-editorial-people-defined-visual-culture-2018">2018 Year in Visual Culture</a>
require quite a bit of planning and cross-team collaboration, as well as customized software development to support
the features that deviate from our current layouts.</p>

<p>Creating the 2019 Artsy Vanguard was truly a company-wide effort! I’m pretty new to Artsy, having only joined last
summer, so some of the work I did on Artsy Vanguard was around understanding our existing framework for routing
article content from <a href="https://github.com/artsy/positron">Positron</a>, Artsy’s editorial API, to
<a href="https://github.com/artsy/force">Force</a>, the code that powers our <a href="https://www.artsy.net/">production site</a>. On the
Engineering side, I collaborated with the project’s technical lead Eve, a senior engineer with years of experience
working in these code repositories. There were several key stakeholders, including, but certainly not limited to, a
lead project manager, lead visuals editor, designers, content writers, as well as the
<a href="http://wax-studios.com/">external design firm</a> that delivered the initial design concept and video content used
for the series.</p>

<a name="Learnings"></a>
<h1>Learnings</h1>

<p>Vanguard was an exciting project, but as with any software endeavor, it came with its own share of learnings and
difficulties.</p>

<a name="L.strong.1..Splitting.time.between.two.teams.is.hard..strong."></a>
<h2><strong>1. Splitting time between two teams is hard</strong></h2>

<p>My team, Grow, is responsible for the development and maintenance of Engineering software related to increasing
user engagement with Artsy’s products. Some of our most notable projects include
<a href="http://files.artsy.net/documents/artsy-bmw-city-guide.pdf">City Guide</a>, an iOS feature built in collaboration with
BMW, detailing art shows and partner fairs in several major international cities,
<a href="https://www.artsy.net/collections">collections</a> and <a href="https://www.artsy.net/collect">collection hubs</a> offering
prospective art buyers more comprehensive ways to explore works and artists of interest, and of course the
<a href="https://www.artsy.net/articles">Artsy Editorial</a>, home to all of our editorial content. We typically work in
two-week sprint cycles, aiming to produce a planned set of deliverables during that time, and collaborating between
other developers on the team, a designer, product manager, data scientist, and technical team leader.</p>

<p>Given that this project involved collaboration from several teams and stakeholders outside of Engineering, we
decided to manage it as a project separate from the rest of the deliverables the Grow team did during the sprints.
This meant I had to split my time between team meetings for Vanguard work and team meetings for Grow. I would keep
the Grow team up to date on the Vanguard work we were doing but it felt like I was in a liminal space between the
two teams. In addition to attending weekly cross-team Vanguard standups, I attended daily Vanguard engineering
standups to align with Eve on the work that we needed to produce. In the interest of protecting my time and not
attending 3 different team standups in a single day, I posted updates to the Grow team via Slack to keep everyone
updated on the progress of our work. Despite our best intentions, it’s difficult to work on two teams at once and
feel fully committed to either.</p>

<a name="L.strong.2..Estimation.is.Hard..strong."></a>
<h2><strong>2. Estimation is Hard</strong></h2>

<p>Due to the way this project was organized, we allotted 1.5 sprint cycles to complete the engineering work. However,
this time allotment was decided on before we had received the completed design specifications from the design firm.
This posed a set of interesting challenges in the sense that the Grow team committed to delivering a feature by a
predetermined deadline without having all of the information needed to understand the full scope of the project. As
with any engineering project, there are often unknown unknowns, those pesky little gotchas that surface as work
commences on a project, but that cannot always be predicted. This presented an interesting lesson in learning how
to estimate the amount of work required to deliver a minimum viable product and reduce the scope to meet certain
deadlines.</p>

<p>Given the limited amount of time to deliver some fairly complex designs, it was clear that we would have to reduce
some of the technical complexity in order to meet the deadline. This is pretty standard in agile development, but
this was the first time that I was in a position of having to deliver this "bad news". It is difficult to tell team
members that a feature is not going to be able to shipped as initially expected, but these are the sort of
concessions that have to be made sometimes in order to deliver a viable product. Fortunately, I was fully supported
by my managers, tech lead, and colleagues in having to deliver the news that we were not going to be able to
deliver a feature identical to the one given to us by the design firm. From this experience, I learned that making
accurate estimations about how much work a project actually involves is hard, relying on agile as a rule makes it
easier, communicating early and often when there’s any uncertainty around delivering a feature by deadline is
critical, and working with team members that value candor, flexibility, communication, and iteration is empowering.</p>

<a name="L.strong.3..CSS.is.Hard..strong."></a>
<h2><strong>3. CSS is Hard</strong></h2>

<p>I get excited about implementing visually delightful designs, and Artsy Vanguard’s 2019 designs did not
disappoint. There were two key components that involved interesting CSS approaches:</p>

<p><strong> 1. Mixed Blending Mode to handle the inversion of the side frame text when it appeared over different
backgrounds</strong></p>

<p><strong> 2. Creating the visual effect of <code>.mp4</code> videos nested inside of SVG shapes</strong></p>

<a name="Mixed.Blend.Mode"></a>
<h2>Mixed Blend Mode</h2>

<p>Mixed blend mode is a CSS property that handles blending the colors of overlapping elements. In this case, we
wanted to create the effect of inverting the colors of the static side frame text when they overlapped with either
the white background, the black SVG shapes, or the SVG videos.</p>

<p>This inverted color effect also needed to be applied to the text of the editorial content when it overlapped with
the black SVG background, when it extended past the SVG background onto a white background, and when the current
article was in an expanded state.</p>

<p>I found <a href="https://css-tricks.com/almanac/properties/m/mix-blend-mode/">CSS-Tricks</a> and the
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode">Mozilla Developer’s Network</a> documentation super
helpful in understanding the various blending properties. Since the designs for Vanguard involved a fairly simple
blending mode of inverting black and white, the mix-blend-mode difference property was how we created the effect of
inverting the black text against the various backgrounds it overlapped with. The blend mode property works by
calculating the rgb color value of the text, and the background-color of the underlying element, and using that
value to determine what colors to render. This inverse calculation also creates the “solarized” effect when the
black side frame text renders over the video-in-SVG.</p>

<p>In the original design specifications, the static text framing the page was intended to render black over a white
background, white over a black background, and white over the video-in-SVG. In order to achieve that effect, we
would have needed to apply the <code>difference</code> mix-blend-mode property when the text overlapped with a black or white
background, and color-dodge when it overlapped with a video-in-SVG background. However, given it is not possible to
assign multiple blending modes to a fixed element we had to deviate from the original design specifications.</p>

<p><img src="/images/2019-11-04-css-is-hard-and-vanguard-2019-learnings/mbb.png" alt="" /></p>

<pre><code class="ts">const FrameText = styled(Sans)`
  position: fixed;
  z-index: 2;
  mix-blend-mode: difference;
  color: rgb(255, 255, 255);
`
</code></pre>

<pre><code class="ts">const InvertedText = styled(Serif)` 
mix-blend-mode: \${p =&gt; (p.isMobile ? "normal" : "difference")}; 
color: rgb(255,255,255); 
will-change: color;
`
</code></pre>

<a name="Video-in-SVG"></a>
<h2>Video-in-SVG</h2>

<p>In the article series you might have noticed that each of the article subsections begins with a different polygonal
shape, which serves as a visual indicator to readers that they are viewing an article either the <em>Emerging</em>, <em>Newly
Established</em>, or <em>Getting Their Due</em> sections. You might have also noticed that each article subseries starts with
a video clip nested inside of one of these corresponding polygon shapes. These are what I refer to as video-in-SVG.
Nothing too in-depth here, but I’ll offer up the initial approach to how this effect was implemented as well as the
final solution.</p>

<p><img src="/images/2019-11-04-css-is-hard-and-vanguard-2019-learnings/getting-their-due.gif" alt="" />
<img src="/images/2019-11-04-css-is-hard-and-vanguard-2019-learnings/getting-their-due-img.png" alt="" /></p>

<p>Initially, I attempted to implement this using the
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject">Foreign Object</a> SVG element and adding a
<a href="https://css-tricks.com/almanac/properties/c/clip-path/">Clip Path</a> CSS property with the to the div element
wrapping the video. In both approaches the video component stopped respecting the responsiveness of the page, which
created an undesirable layout effect of having a huge video on screens smaller than 600 pixels wide, and
disproportionate sizing relative to the rest of the components in the article series.</p>

<p>In order to achieve the desired effect, the component was refactored to make the SVG "blob" a sibling of the video
wrapped inside a parent div with a fixed height. The parent div received a height equal to 100% of the viewport
width divided by the video’s aspect ratio--16:9. This prevents the video from being visible outside the borders of
the SVG. Et voila!</p>

<pre><code class="ts">const SubseriesWrapper = styled(Flex)`
  flex-direction: row;
  position: relative;
  z-index: -2;
  /* 16 x 9 aspect ratio */
  height: calc(100vw * 0.56);
`
</code></pre>

<pre><code class="html">&lt;SubseriesWrapper&gt;
  &lt;SubseriesSVGWrapper&gt;
    &lt;svg viewBox="0 0 1600 900" xmlns="http://www.w3.org/2000/svg" fill="FFF" width="100vw"&gt;
      &lt;path d="M0,0V900H1600V0ZM1489.83,896.43,146.61,805.5,47.2,182.84,320,4.17l874.07,86,360.06,148Z" /&gt;
    &lt;/svg&gt;
    &lt;VanguardSubseriesVideoWrapper&gt;
      &lt;VanguardSubseriesVideo autoPlay loop muted playsInline controls="{false}" src="{props.url}" /&gt;
    &lt;/VanguardSubseriesVideoWrapper&gt;
  &lt;/SubseriesSVGWrapper&gt;
&lt;/SubseriesWrapper&gt;
</code></pre>

<a name="Final.Thoughts"></a>
<h1>Final Thoughts</h1>

<p>One of the biggest non-technical takeaways for me was the importance of becoming skilled at thinking like a product
manager while approaching engineering work. Engineers that do this well are adept at balancing many
responsibilities–scoping out the amount of engineering work involved in producing a deliverable, communicating
technical information to non-technical team members, managing expectations and (sometimes) competing interests when
working on cross-teams projects, gracefully informing stakeholders that the scope of a project will have to be
limited in order to deliver an MVP, among others. Doing these things well is hard, and furthermore not something we
learn in computer science or engineering programs; yet is a requisite, in my opinion, to be an effective engineer.
I’m grateful for the opportunity to have collaborated with others on this year’s Artsy Vanguard and to have been
given the chance to develop these skills.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generating Notifications and Personalized Emails Efficiently]]></title>
    <link href="https://artsy.github.io/blog/2014/04/24/generating-notifications-and-personalized-emails-efficiently/"/>
    <updated>2014-04-24T16:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2014/04/24/generating-notifications-and-personalized-emails-efficiently</id>
    <content type="html"><![CDATA[<p>We recently launched a new personalized email here at <a href="https://artsy.net">Artsy</a> that features content that a given user might find interesting. The goal of this post is to describe how we built a backend system that efficiently generates these e-mails for all our users. I'll talk about the first, naive implementation that had performance problems right away, and how the second implementation (currently in production) solved those issues, and whose behavior at scale is well-defined and understood. I won't go into the details of the design and layout of the mail itself and how we render the content - there are several earlier blog posts that deal with those: <a href="http://artsy.github.io/blog/2014/03/18/presenters-and-memoization-moving-logic-out-of-templates/">Presenters and Memoization</a>, <a href="http://artsy.github.io/blog/2014/03/17/ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email/">Pinterest-style Layouts</a> and <a href="http://artsy.github.io/blog/2014/03/17/some-tips-for-email-layout-and-responsiveness/">Email Layouts and Responsiveness</a>.</p>

<p><img src="/images/2014-04-24-generating-notifications-and-personalized-emails-efficiently/percy_example.png" alt="Personalized Email Example" /></p>

<!-- more -->


<a name="Deciding.What.Content.to.Include"></a>
<h3>Deciding What Content to Include</h3>

<p>First, we had to decide what types of personalized content we wanted to feature in our mails. Users can follow artists and galleries, and so this seemed like a great place to start. We'd like to let you know about new artworks that have been uploaded by artists that you follow, as well as new shows that have been added by galleries you follow, or that are exhibiting artists you follow. Since we have location data for our galleries and our users (accomplished thru an onboarding flow, or thru geo-locating their IP address), we also want to include new shows that are opening near you. Additionally, we have a recommendations engine that recommends artworks to users based on their preferences and activity on the site, and we'd like to show some of the latest and best of such recommendations.</p>

<a name="Initial.Implementation.Ideas"></a>
<h3>Initial Implementation Ideas</h3>

<p>My first thought was to have an observer (really just some <code>after_save</code> callbacks) that will wait for data to get into a state where a user can be validly notified, and in a background task write these notifications to interested users. Here's how the base setup of our <code>Notification</code> model looked:</p>

<pre><code class="ruby">class Notification
  include Mongoid::Document
  include Mongoid::Timestamps

  belongs_to :user
  belongs_to :notifiable, polymorphic: true, inverse_of: :notifications
end
</code></pre>

<p>It's a simple join of the user and the <code>notifiable</code> (the object/action that a user is being notified about).</p>

<p>Then, a specific notification (such as one for published artworks by artists you follow) can inherit from this and look like:</p>

<pre><code class="ruby">class PublishedArtworkNotification &lt; Notification
  def self.notify!(artwork_id)
    user_ids = FollowArtist.where(artist: artwork.artist).pluck("user_id")
    user_ids.each_slice(100) do |uids|
      PublishedArtworkNotification.delay(queue: :any, priority: 6).create_for_users(artwork_id, uids)
    end
  end

  def self.create_for_users(artwork, uids)
    uids.each do |uid|
      PublishedArtworkNotification.create!(user_id: uid, notifiable_id: artwork_id, notifiable_type: 'Artwork')
    end
  end
end
</code></pre>

<p>Then, the <code>after_save</code> hook on an <code>Artwork</code> model is:</p>

<pre><code class="ruby">def delay_notify
  PublishedArtworkNotification.delay(queue: :any).notify!(self.id) if self.published_changed? &amp;&amp; self.published
end
</code></pre>

<p>So, when an artwork is published, we run <code>notify!</code> in the background for the respective notification. That method will pull all interested users (via following the artist), and then spawn off more background processes to write the notifications in batches of 100. We batched these writes to avoid any one background process taking too long (an artist such as <a href="https://artsy.net/artist/andy-warhol">Andy Warhol</a> has around twelve thousand followers currently), and also ran them at a lower priority to avoid blocking other jobs in our queue.</p>

<p>The other types of notifications were all implemented similarly (via an observer on the model, and a specific <code>Notification</code> class inheriting from the base class). We also added some other logic into the base <code>Notification</code> class such as some uniqueness constraints, as well as an ability to mark notifications as 'sent' or 'invalid'. However, we ran into serious performance/scaling issues fairly quickly, and had to re-implement this scheme.</p>

<a name="Performance.Bottlenecks"></a>
<h3>Performance Bottlenecks</h3>

<p>All of these records were being written to one collection in <a href="https://www.mongodb.org/">MongoDB</a>, and the size of this collection grew quite rapidly. It's size almost immediately dwarfed the size of any of our other collections, and the number of records quickly reached into the tens of millions. This led to problems: writing new notifications started to crawl to a standstill. We had several indices on this collection to aid in querying, and these made the insertion of new notifications very non-performant, and also started to affect overall database performance. Querying against this collection degraded quickly and started to similarly affect database performance. Archiving old records also proved next to impossible. We couldn't simply drop the entire collection, but had to prune records. This similarly was totally non-performant and was adversely affecting database and site performance. We needed to come up with a new implementation for <code>Notification</code>, and addressing these issues was essential.</p>

<a name="Resolving.Performance.Bottlenecks"></a>
<h3>Resolving Performance Bottlenecks</h3>

<p>So, we decided on a scheme where each day would result in a new <code>Notifications</code> collection (name keyed on the date), named <code>notifications_20140101</code>, <code>notifications_20140102</code>, etc. Each of these collections would have an <code>_id</code> field that corresponds to a user_id, and an <code>events</code> array (or 'stack' if you will) that records the id's of notified objects, as well as the type of notification. An example of a record in that collection is:</p>

<pre><code class="json">{"_id"=&gt;"5106b619f56337db300001f8",
 "events"=&gt;[{"t"=&gt;"NearbyShow", "o"=&gt;"533998b1c9dc24c371000041"},
            {"t"=&gt;"NearbyShow", "o"=&gt;"5345774cc9dc246d580003d0"},
            {"t"=&gt;"NearbyShow", "o"=&gt;"5335af4fa09a67145300028c"},
            {"t"=&gt;"NearbyShow", "o"=&gt;"533f1174a09a67298900007b"},
            {"t"=&gt;"ArtworkPublished", "o"=&gt;"5334647b139b2165160000d8"}]
}
</code></pre>

<p>So, here we see all of my notifications for April 22, 2014. On that day, I was notified about 4 shows opening near my location, and one artwork added by an artist I follow. Incidentally, that artwork was a piece by <a href="https://artsy.net/artist/rob-wynne">Rob Wynne</a> entitled <a href="https://artsy.net/artwork/rob-wynne-youre-dreaming">You're Dreaming</a>. The show notifications were for NYC-area shows opening at <a href="https://artsy.net/klein-sun-gallery">Klein Sun Gallery</a>, <a href="https://artsy.net/garis-and-hahn">Garis &amp; Hahn</a>, <a href="https://artsy.net/miyako-yoshinaga-gallery">Miyako Yoshinaga Gallery</a> and <a href="https://artsy.net/dodgegallery">DODGEgallery</a>.</p>

<p>A couple of nice things about this implementation is it limits the size of a collection: any one day's collection will scale directly with the number of users, which seems reasonable. Our earlier implementation scaled with the product of the number of users and amount of content on Artsy, which is clearly problematic. Also, archiving old notifications is as simple as dropping a particular day's collection, which is very performant. However, querying and assembling these notifications is a bit trickier than in the naive implementation, as well as marking which events have already been sent to a user, so as to avoid duplicating any content in between mailings.</p>

<p>Let's see how we rewrite the notification generation in this scheme:</p>

<pre><code class="ruby">module NotificationService

  def self.notify_many!(user_ids, object_id, type)
    events = events_from(object_id, type)
    user_ids.each do |user_id|
      notify_with_events(user_id, events)
    end
  end

  private

  def self.notify_with_events(user_id, events)
    collection.find(_id: user_id).upsert('$push' =&gt; { events: { '$each' =&gt; events } })
  end

  def self.events_from(object_ids, type)
    Array(object_ids).map do |object_id|
      {
        't' =&gt; type,
        'o' =&gt; object_id
      }
    end
  end

  # collection storing notifications for the given day
  def self.collection(date = Date.today)
    Mongoid.default_session.with(safe: false)[collection_name(date)]
  end

  def self.collection_name(date)
    "notifications_#{date.to_s(:number)}"
  end

end
</code></pre>

<p>Here's how the <code>after_save</code> callback looks now:</p>

<pre><code class="ruby">def notify_published
  NotificationService.notify_many!(user_ids, self, 'ArtworkPublished') if self.published_changed? &amp;&amp; self.published
end
</code></pre>

<p>Let's take a look at what's going on here. When an artwork is published, we call <code>notify_many!</code> in the <code>NotificationService</code> module. That will determine the correct collection (keyed by the date) using the <code>collection</code> and <code>collection_name</code> helpers. We build our events stack with the <code>events_from</code> helper, and then do an <code>upsert</code> with a <code>$push</code> to either insert or update that user's events for that day. Due to the fast performance of this scheme, we also no longer have to batch notification creation. As a sample benchmark, writing this type of notification to our <a href="https://artsy.net/artist/andy-warhol">Warhol</a> followers takes under 15 seconds.</p>

<p>Ok, so we seem to have solved some of our issues: namely writing and archiving notifications is performant, and we understand the behavior of these collections as the number of users and content on the site grows. Now let's look at how we can query against this scheme in an efficient manner, and also how we can mark events as 'seen' to avoid emailing out duplicates.</p>

<a name="Marking.Notifications.as.Flushed.and.Retrieving.Notifications"></a>
<h3>Marking Notifications as Flushed and Retrieving Notifications</h3>

<p>We decided to push a <code>flushed</code> event onto the user's stack after we send out notifications, and analogously, when we are querying a user's notifications, we want to throw away notifications that occur before a <code>flushed</code> event. Here's that method, in our <code>NotificationService</code> module:</p>

<pre><code class="ruby"># Mark all events until this point "seen." Pushes a {flushed: &lt;id&gt;}
# hash on to events array.
def self.flush!(user_id, since = Date.today - 7.days)
  flushed = { 'flushed' =&gt; Moped::BSON::ObjectId.new }
  collections_since(since).each do |coll|
    coll.find(_id: user_id).update('$push' =&gt; { events: flushed })
  end
  flushed  # return "id" of flushed marker, in case useful later
end

private

def self.collections_since(date)
  (date..Date.today).map { |d| collection(d) }
end
</code></pre>

<p>Pretty simple. We push the appropriate event onto every collection that was under consideration via the <code>collections_since</code> helper. When we send out a personalized email we accumulate the last 7 day's worth of activity for you, and so after we generate/send a mail for a user, we can simply say <code>NotificationService.flush!(user)</code>. Here's how that day's notifications for me looks after the <code>flushed</code> event:</p>

<pre><code class="json">  {"_id"=&gt;"5106b619f56337db300001f8",
   "events"=&gt;[{"t"=&gt;"NearbyShow", "o"=&gt;"5338504e139b21f2a9000362"},
              {"t"=&gt;"FollowedArtistShow", "o"=&gt;"533ddba3a09a6764f60006b6"}, {"t"=&gt;"NearbyShow", "o"=&gt;"533ddba3a09a6764f60006b6"},
              {"flushed"=&gt;"5352b346b504f5f3690002fe"}]
  }
</code></pre>

<p>For the last piece of the puzzle, let's look at how we query against this scheme and compile together all notifications that are applicable for a given user:</p>

<pre><code class="ruby">module NotificationService
  NOTIFICATION_TYPES = {
    'FollowedArtistShow' =&gt; PartnerShow,
    'FollowedPartnerShow' =&gt; PartnerShow,
    'NearbyShow' =&gt; PartnerShow,
    'ArtworkPublished' =&gt; Artwork,
    'ArtworkSuggested' =&gt; Artwork
  }

  class Notification &lt; Struct.new(:type, :object_id)
    def object
      @object ||= NOTIFICATION_TYPES[type].find(object_id)
    end

    def applicable?
      object.try(:notifiable?) || false
    end
  end

# Return applicable notifications for user since given date.
def self.get(user_id, since = Date.today - 7.days)
  collections_since(since)
    .map { |coll| coll.find(_id: user_id).one }.compact
    .flat_map { |doc| doc['events'].slice_before { |ev| ev['flushed'] }.to_a.last }
    .reject { |ev| ev['flushed'] }.uniq
    .map { |ev| Notification.new(ev['t'], ev['o']) }.select(&amp;:applicable?)
end
</code></pre>

<p>We introduce a lite-weight <code>Notification</code> class that will load the object, as well as perform an additional check. We use the previously introduced <code>collections_since</code> helper to retrieve all the notification collections under consideration. We query each and build up an array of all events from a user's stack. We remove events that occurred prior to a <code>flushed</code> event in a given collection and the <code>flushed</code> events themselves. Then we actually load all the objects and return the ones that are still <code>applicable?</code>. That final <code>applicable?</code> check is to allow us to filter out content at run-time that is no longer valid. For example, if an artwork is published and the correct event is written out to users, but before the user can be notified the artwork is unpublished, this can serve as a run-time check to not include that work. <code>def notifiable?</code> can thus be implemented in the <code>Artwork</code> model like so:</p>

<pre><code class="ruby">def notifiable?
  published?
end
</code></pre>

<p>And...that's basically it! Throughout the week as partners are uploading their shows/fair booths/artworks, these records are being opportunistically written to that day's notification collection, in a performant and scalable fashion. Then when we want to send you a personalized email, we pull all your appropriate notifications via the <code>get</code> routine in our <code>NotificationService</code>, and primarily using the technique described in <a href="http://artsy.github.io/blog/2014/03/18/presenters-and-memoization-moving-logic-out-of-templates/">Presenters and Memoization</a> we make sure we cache/memoize all such data. Using the tips in <a href="http://artsy.github.io/blog/2014/03/17/ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email/">Pinterest-style Layouts</a> and <a href="http://artsy.github.io/blog/2014/03/17/some-tips-for-email-layout-and-responsiveness/">Email Layouts and Responsiveness</a> we can render this content and support various devices/email clients. We parallelize and batch the generation/sending of our e-mails as well. This whole system, from notification generation to actually emailing users, is running successfully and smoothly in production.</p>

<a name="Next.Steps"></a>
<h3>Next Steps</h3>

<p>I think this type of infrastructure can easily be adapted to serve as a feed on a front-end or other client app. An API to serve up these notifications (AKA feed items) can be built and different feed items can then be rendered or aggregated at load-time. Simple client-side polling can even be set up to alert a user if something has happened that interests them <em>while</em> they're browsing! I think push notifications and other messaging can be handled by this system as well.</p>

<p>I'd love to hear any feedback and thoughts, and hopefully you've found this post informative and interesting. Please leave any feedback in the comments and <a href="https://github.com/artsy">follow us on Github</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Helper to Group Artworks into a Pinterest-style Layout for Email]]></title>
    <link href="https://artsy.github.io/blog/2014/03/17/ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email/"/>
    <updated>2014-03-17T19:32:00+01:00</updated>
    <id>https://artsy.github.io/blog/2014/03/17/ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email</id>
    <content type="html"><![CDATA[<p><img src="/images/2014-03-17-ruby-helper-to-group-artworks-into-a-pinterest-style-layout-for-email/two-column-layout.png" alt="Example of two column layout" /></p>

<p>Something we'd like to do is email our users some suggested artworks as part of their personalized emails. The layout of those suggestions should look something like our newly re-designed <a href="https://artsy.net/browse/artworks?price_range=-1%3A1000000000000">Browse</a> page, with a 'salon' style layout. Here's some simple Ruby code that can group artworks into columns for you, that can then be directly rendered in an email (via <a href="http://haml.info/">Haml</a>, <a href="http://mustache.github.io/">Mustache</a>, <a href="http://jade-lang.com/">Jade</a>, or your templating language of choice.)</p>

<!-- more -->


<a name="The.code"></a>
<h2>The code</h2>

<p>First let's look at the code, and then I'll describe it:</p>

<pre><code class="ruby">module ArtworkColumns
  # Return an array of artworks grouped together in sub arrays by being added to the shortest 'column'
  # based on a fixed width and aspect ratios.
  #
  # @param {Array} artworks The array of artworks to group into columns
  # @param {Number} num_columns The number of columns to group them into
  # @param {Number} width The width the images will be displayed at
  #
  # @return {Array} An array of artworks grouped into sub arrays by being added to the shortest one.
  def self.artwork_columns(artworks, num_columns, width)
    artwork_cols = []

    # Initialize columns
    num_columns.times do
      artwork_cols &lt;&lt; []
    end

    artworks.each do |artwork|
      add_to_shortest_column!(artwork_cols, artwork, width)
    end

    artwork_cols
  end

  private

  # Adds artwork to shortest column
  def self.add_to_shortest_column!(artwork_cols, artwork, width)
    min_height = column_height(artwork_cols[0], width)
    min_column_idx = 0

    artwork_cols.each_with_index do |column, idx|
      height = column_height(column, width)
      if height &lt; min_height
        min_height = height
        min_column_idx = idx
      end
    end

    artwork_cols[min_column_idx] &lt;&lt; artwork
  end

  # Calculate sum of heights of artworks in column
  def self.column_height(artwork_col, width)
    height = 0
    artwork_col.each do |artwork|
      if (aspect_ratio = artwork.default_image.aspect_ratio)
        height += (width / aspect_ratio).floor
      else
        height += width
      end
    end
    height
  end
</code></pre>

<p>The algorithm is quite simple (original JS idea and implementation courtesy of Artsy's <a href="https://github.com/gib">Gib</a>). The inputs are fairly obvious, an array of artworks to be grouped, the number of columns to group them into, and the width of each column.</p>

<p>We then simply iterate over all our artworks, and add them to whichever column is shortest. This way we end up with several columns that are for the most part equally sized in height, and as they all have different aspect ratios, when they are rendered in a table, you wind up with a nice looking 'dynamic' layout. The height of each column is calculated as the sum of the heights of the artworks in each column. The heights are derived from the inputted widths and aspect ratios of the images.</p>

<p>Here's how you might iterate over the returned column groupings and render a layout similar to the above:</p>

<pre><code class="haml">- artwork_suggestions.each_with_index do |artwork_arr, idx|
  %td{ id: 'artwork-column', style: "width: 290px;padding-top:20px;text-align:left;" }
    - artwork_array.each do |artwork|
      %a{ href: "#{canonical_url}/artwork/#{artwork.slug}?#{@utm_params}" }&lt;
        %img{ id: 'artwork', src: "#{artwork.default_image.image_url(:large)}", style: "width: 290px;" }
      %br
      &lt;!-- additional artwork details, title, artist, etc. --&gt;
</code></pre>

<p>These few lines of Ruby code have allowed us to move logic out of Haml (yuck!) and into Ruby (yay!) and allow <a href="http://haml.info/">Haml</a> to just focus on rendering the objects passed in (certainly via loops and conditionals, etc.)</p>

<p>That's all for now! In my next post I'll talk about how I use the Presenter pattern and memoization to move even more logic out of templates (and save some database calls while we're at it!)</p>

<p>Thanks again! Post any comments or tips of your own here, and <a href="https://github.com/artsy">follow us on Github</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Tips for Email Layout and Responsiveness]]></title>
    <link href="https://artsy.github.io/blog/2014/03/17/some-tips-for-email-layout-and-responsiveness/"/>
    <updated>2014-03-17T12:36:00+01:00</updated>
    <id>https://artsy.github.io/blog/2014/03/17/some-tips-for-email-layout-and-responsiveness</id>
    <content type="html"><![CDATA[<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/analytics.png" alt="Example of Analytics Email" /></p>

<p>Email can be one of the most powerful ways to engage with your users, and can serve a multitude of purposes. It can be used as a way to highlight selected content (weekly/monthly newsletters, 'year in review', etc.), provide a service to users (analytics breakdown of visits to your profile/favorites page), or re-engage with users (new feature announcements, etc.). Here at Artsy we use all of these kinds of emails and have found them to be a very valuable asset. However, best practices for template layout and CSS (keeping in mind the variety of devices and screen sizes that your users have) are quite different from, and very far behind, the current HTML5 standards and practices for making beautiful web pages. In this article, I'd like to present some techniques I've successfully used at Artsy to create emails that look good on your browser or mobile device, in some of the most popular email clients out there.</p>

<!-- more -->


<a name="The.Main.Difference.Between.Email.and.Web"></a>
<h2>The Main Difference Between Email and Web</h2>

<p>A fundamental difference between email and web, and which essentially accounts for the completely different methodology and rules you should follow for emails, is that of the rendering client. In 2014, (assuming you are not supporting certain legacy versions of Internet Explorer and other old versions), browsers for the most part will render passed in HTML and CSS in a standard fashion. While there are some notable exceptions still, graceful degradation is quite possible. That is because the only 'interpreter' of your HTML is the end user's browser, which operates under a certain set of known rules. With emails however, the interpreter is the end user's mail client of choice, which can be: native iOS apps, web apps, and even standalone desktop applications. All of these do their own parsing/interpreting before rendering, which can cause HTML that results in a nice looking web page to look totally broken in an email, as well as the same exact email looking remarkably different across mail clients. One of the main reasons why email clients do this is to remove things that might interfere with the rendering of the mail client itself, or any security risks.</p>

<p>Also of note is that the use of Javascript within an email is of course, not possible. Additionally, the HTML that will be emailed to your users needs to be sent as one file with inlined CSS. You can use a tool like <a href="https://github.com/premailer/premailer/">premailer</a> to allow you to develop your CSS separately and then convert to an inline style.</p>

<a name="Some.Basics.about.Tables"></a>
<h2>Some Basics about Tables</h2>

<p>Yes, it's 2014, and yes, we're going to talk about tables on an engineering blog. That's because for emails, tables are going to be your main tool to position and lay out your content. Two of the most common CSS selectors (<code>position</code> and <code>display</code>) are bad ideas to use in email. They are mostly unsupported by mail clients (which will reach in and rewrite your HTML/CSS) and will lead to unexpected looking output. However, you can achieve virtually any layout desired using tables.</p>

<p>Here is sample HTML that generates the top part of the email shown above. While it may make your eyes bleed from the table use, notice we are able to achieve the beginnings of a basic 3-column layout, with equal-width columns and centered headers/text with no position-related CSS.</p>

<p>``` html</p>

<table border='0' cellpadding='0' cellspacing='0' style='margin: 0 20px; table-layout: fixed;' width='600px'>
  <tr>
    <td align='center' colspan='3' style='padding: 0px 0px 15px' valign='middle'>
      <font color='black' style='font-family: Georgia, serif;font-size: 16px; line-height: 1.3em; letter-spacing:2px;text-transform:uppercase;'>
        Cats Galore at the Cat Art Fair 2014
      </font>
    </td>
  </tr>
  <tr>
    <td align='left' style='padding: 0px 0px 15px; border-right: 1px solid grey;' valign='middle'>
      <font color='black' style='font-family: Georgia, serif;font-size: 16px; line-height: 1.3em;'>
        <div style='text-align: center; font-size: 23px;'>
          24
        </div>
        <div style='text-align: center;'>
          works
          in your booth
        </div>
      </font>
    </td>
    <td align='middle' style='padding: 0px 0px 15px; border-right: 1px solid grey;' valign='middle'>
      <font color='black' style='font-family: Georgia, serif;font-size: 16px; line-height: 1.3em;'>
        <div style='text-align: center; font-size: 23px;'>
          3,086
        </div>
        <div style='text-align: center;'>
          total artwork views
        </div>
      </font>
    </td>
    <td align='right' valign='middle'>
    <font color='black' style='font-family: Georgia, serif;font-size: 16px; line-height: 1.3em;'>
      <div style='text-align: center; font-size: 23px;'>
        471
      </div>
      <div style='text-align: center;'>
        cities reached
      </div>
    </font>
    </td>
  </tr>
  <!-- more content below -->
</table>


<pre><code>
Now under this we present a heatmap and table of top views by city. For that we use the same 3-column table, except specify a colspan of 2 on the column that contains the heatmap. That is because we would like that column to take up a width equal to the first 2 columns of the equally spaced three at the top, and the table of top views will take up the last column. Here's that markup:
</code></pre>

<pre><code>&lt;tr&gt;
&lt;td align='left' colspan='2' style='padding: 0px 0px 15pxl; width: 66%;' valign='middle'&gt;
  &lt;div&gt;
    &lt;img src='link_to_heatmap.png' width='400px'&gt;
  &lt;/div&gt;
&lt;/td&gt;
&lt;td align='right' style='padding: 0px 23px 15px; width: 33%; text-align:left;' valign='middle'&gt;
  &lt;font color='black' style='font-family: Georgia, serif;font-size: 12px; line-height: 1.3em; font-weight:bold;'&gt;
    Top 10 Cities
  &lt;/font&gt;
  &lt;font color='black' style='font-family: Georgia, serif;font-size: 12px; line-height: 1.3em;'&gt;
    New York
    21.66%
    &lt;br&gt;
    London
    3.34%
    &lt;br&gt;
    &lt;!-- 'br' separated string of views --&gt;
  &lt;/font&gt;
&lt;/td&gt;
</code></pre>

<p>  </tr>
```</p>

<p>Notice that again we are using no position or display related CSS. However, now our table has a 3 column section and a 2 column section, and we are well on our way to creating a nice email! I kept these as separate rows in the same table, but could have equivalently had each of them be their own table with no ill effects and almost the same markup. Depending on your design and layout, you may need to have multiple tables (nested and not) to support different widths and column layouts, however they should all just <em>work</em>.</p>

<a name="Background.Images.and.Overlayed.Text"></a>
<h2>Background Images and Overlayed Text</h2>

<p>Ok, so tables are all well and good and you can achieve a lot using them, and without having to use any display or position CSS. But what if you want to overlay text on an image? (or even another image over an image)? On a web page, there are many ways to accomplish that, but they all use CSS that you really should not be using in emails (namely: <code>position</code>, <code>display</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>, and most layout properties besides padding. Also, no negative padding please!). But no worries, because you can still accomplish that using background images!</p>

<p>Here is an example from our current welcome mail to users:</p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/welcome_desktop.png" alt="Example of Welcome Mail" /></p>

<p>The top part (the iPhone pic) is actually two images (the picture, and the App Store logo), as well as some text overlayed on top. Here is the HTML to accomplish that:</p>

<p>``` html</p>

<table cellpadding='0' cellspacing='0' id='iphone-table' style='border: 0;padding:10px 0px 15px 0px;width:625px' width='625'>
  <tr>
    <td align='left' valign='middle'>
      <table background='link_to_phone.png' cellpadding='0' cellspacing='0' height='265' style='height:265px;width:625px' width='625'>
        <tr>
          <td style='padding-top:57px;padding-right:53px;padding-left:375px;text-align:center;'>
            <div style='line-height:26px;'>
              <font style='text-transform: uppercase; font-size: 19px; font-family: Georgia, serif; color: white;-webkit-font-smoothing:antialiased;'>
                Download Artsy for iPhone
              </font>
            </div>
            <div style='padding-top:10px;'>
              <font style='font-size: 14px; font-family: Georgia, serif; color: white;-webkit-font-smoothing:antialiased;'>
                The art world in your pocket.
              </font>
            </div>
          </td>
        </tr>
        <tr>
          <td align='right' style='padding-right:82px;vertical-align:top;'>
            <a href='https://itunes.apple.com/us/app/artsy-art-world-in-your-pocket/id703796080?ls=1&amp;mt=8'>
              <img src='app_store.png' style='border: none; outline: none; vertical-align:top;' width='140px'>
            </a>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>


<pre><code>
I chose to use a separate table to hold this content, where the background image for this table is the picture of the iPhone in hand. That table (with a background of the photo) has two rows, each with one column. The first row which is for the top part of the image, contains the 'Download' white text. That is positioned within the column through padding, which is well supported by most mail clients (as long as it's positive padding that is!) The second row, for the bottom part of the image, is a picture of the 'Download on the App Store' logo, and we chose to put that in an anchor tag and link to the App Store. You could have alternatively made this image a background as well to achieve the same overlay effect, as well as added more overlaid text, etc.

Essentially, to overlay text on images, and images on images - your only option in email is to use background images.

## Mobile Responsiveness

Ok, at this point we know how to craft some 'dynamic' layouts, (multi-column, sidebar, etc) and can overlay text and images for added effect. Now let's think about how this should work/look on a mobile device. Media queries will be our tool of choice here (well supported by mobile mail clients, with a notable exception being the Gmail iOS app.)

Something to keep in mind, depending on your use case, is to potentially design the email in the first place with mobile in mind. This can mean larger font sizes across the layout, as well as a single or two column layout max for your content. Since you have much less screen space to work with on mobile, the media queries we are going to use will largely be to increase font sizes, as well as using 'width' and 'float' to force a two column layout into one column (as an example). Depending on the mail design, this can be simple to do, or quite tricky. It's worth considering this in your initial designs.

Now the first thing to do is to include the following meta tag in your HTML:
</code></pre>

<p>  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
```</p>

<p>This will tell the browser to treat the viewport size as the size of the device that is being used. This combined with media queries will enable us to create mobile emails.</p>

<p>As an example, consider the following two images. The first is the desktop version of the top part of a personalized weekly mail (blog post on how we efficiently generate these to come!), and the second is the mobile version of that same mail.</p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/personalized_desktop.png" alt="Example of Personalized Desktop" /></p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/personalized_summary.png" alt="Example of Personalized Mobile" /></p>

<p>The markup for this is pretty vanilla (similar to above, 3 column layout in a table). For mobile, we want to left-align everything and trim things down to one column. Of note here is that we are truncating text with ellipsis in the desktop version, and when the content reflows to one column we actually have <em>more</em> room to reveal the text (but still keeping truncation in just in case), so we have to enclose the text in a <code>div</code> (must have a block element for truncation)</p>

<p>Here is how we truncate text:</p>

<pre><code class="html">  &lt;div id='row-to-expand' style='white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:150px;'&gt;
    Some really long text that will get truncated
  &lt;/div&gt;
</code></pre>

<p>We specify a width on a block-level element and then use the ellipsis trick. Here's another screenshot of the truncation in action:</p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/personalized_shows.png" alt="Example of Shows Listing" /></p>

<p> Our first media query can be something like:</p>

<pre><code class="css">  @media (max-device-width: 320px){
    div[id='row-to-expand']{
      width: 260px !important;
    }
  }
</code></pre>

<p>We've set the breakpoint at 320px (vertical layout on an iPhone), and at widths less than or equal to that, this rule will kick in. Note the '!important' at the end (all of our media queries will have that to allow them to override the existing inline CSS). This is enough to expand that div and reveal more text.</p>

<p>Here's the media queries for the rest of this section that transforms the three column layout into one:</p>

<pre><code class="css">  @media (max-device-width: 320px){
    td[id='summary-col']{
      float: left !important;
    }
    td[id='summary-header']{
      float: right !important;
      width: 300px !important;
    }
    td[id='nested-summary-col']{
      width: 300px !important;
      float: left !important;
      padding: 0px !important;
    }
    table[id='summary']{
      width: 300px !important;
    }
  }
</code></pre>

<p>where the <code>td[id='nested-summary-col']</code> are the <code>td</code>s that hold the thumbnail and artist or gallery name.
Essentially all we are doing is changing the width of the container/parent table to 300px, and then making the width of each <code>td</code> 300px and adding a float. This will force your table to now be a one column layout- easy!</p>

<a name="Some.misc..email.tweaks"></a>
<h3>Some misc. email tweaks</h3>

<p>Sometimes it becomes necessary to hide/show certain things for mobile or desktop. This can be a bit tricky due to not being able to use <code>display:none;</code> , so here are a few things I've found that worked:</p>

<ul>
<li><code>width: 0px;</code> (works for hiding images)</li>
<li><code>line-height: 0px;</code> (works for hiding text)</li>
<li><code>font-size: 0px;</code> (works for hiding text)</li>
</ul>


<p>Another thing you might encounter is that text links automatically become blue in email. This is because many mail clients will take an un-styled or black link text and make them a default blue color. An easy hack to get around this is to explicitly color your links something like '#000001'. This 'almost-black' will be left untouched by mail clients, yet is close enough to black that the naked eye can't perceive the difference.</p>

<p>Here's a screenshot of an <a href="https://github.com/desandro/isotope">isotope</a> or <a href="https://www.pinterest.com/">Pinterest</a> column style layout, with truncation of text, and resized for mobile (running the full gamut of tricks):</p>

<p><img src="/images/2014-03-17-some-tips-for-email-layout-and-responsiveness/personalized_suggestions.png" alt="Example of Personalized Suggestions" /></p>

<p><a href="https://gist.github.com/mzikherman/9610125">Here is a gist</a> I use to prepare artworks for a columnar display like this. You pass in a collection of artworks (where each artwork is arbitrarily sized), and the number of columns and width of the desired output. It will return the artworks grouped into columns that can be directly rendered in an email, while respecting aspect ratios and ensuring the columns are of <em>approximately</em> equal height - resulting in a dynamic feeling layout. For this email, we group this set of artworks into 2 coumns, with each column having a width of 300px (for desktop).</p>

<a name="Great.tools.to.use:"></a>
<h2>Great tools to use:</h2>

<ul>
<li><a href="https://github.com/premailer/premailer/">Premailer</a> This will enable you to develop CSS in a sane (ie- not inline) way, and then at generation/compile time, inline it for you.</li>
<li><a href="http://litmus.com/">Litmus</a> Using Litmus's VM's with different OS's and mail clients, you can preview how a sample email will look among all sorts of different configurations. I recommend figuring out what mail clients/browsers/OS's you want to target and making sure you test all your emails here.</li>
<li><a href="http://haml.info/">Haml</a> (or any templating language of choice). A lot of the blocks of content in our mails are dynamically generated, and Haml's conditionals and looping syntax, as well as
Ruby-style string evaluation has proven invaluable.</li>
</ul>


<hr />

<p>That's all for now! With a lot of trial and error, I've built up a toolbelt of tricks, techniques and hacks I've been using to develop responsive and pretty emails quickly. I think of the limited set of tools at my disposal as a puzzle with which you can still create great looking and responsive layouts to feature your content. Previewing mails using <a href="http://mailchimp.com/features/inbox-inspector/">Inbox Inspector</a> have enabled me to craft, deploy, and send them to our users with confidence. Post any comments or tips of your own here, and <a href="https://github.com/artsy">follow us on Github</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS Trick: Adjusting Text Underlines]]></title>
    <link href="https://artsy.github.io/blog/2012/04/10/css-trick-adjusting-text-underlines/"/>
    <updated>2012-04-10T16:32:00+02:00</updated>
    <id>https://artsy.github.io/blog/2012/04/10/css-trick-adjusting-text-underlines</id>
    <content type="html"><![CDATA[<p>Often times people will use <em>border-bottom: 1px solid</em> in favor of <em>text-decoration: underline</em> to give their links some breathing room. But what if you're giving it <em>too</em> much breathing room and want to adjust the height of that underline. With Adobe Garamond that happened to be the case, so we've come up with this little css trick:</p>

<pre><code class="css">a {
  display: inline-block;
  position: relative;
}
a::after {
  content: '';
  position: absolute;
  left: 0;
  display: inline-block;
  height: 1em;
  width: 100%;
  border-bottom: 1px solid;
  margin-top: 5px;
}
</code></pre>

<p>This overlays a CSS pseudo element with a border-bottom that can be adjusted by changing margin-top.</p>

<p>For handling browsers that don't support pseudo elements I recommend targeting them with the <a href="http://paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/">Paul Irish class-on-html-trick</a>.</p>

<p>Let your links breathe!</p>
]]></content>
  </entry>
  
</feed>
