<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: typescript | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/typescript/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2021-10-06T21:47:56+02:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What is TypeScript?]]></title>
    <link href="https://artsy.github.io/blog/2019/04/05/omakase-typescript/"/>
    <updated>2019-04-05T00:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2019/04/05/omakase-typescript</id>
    <content type="html"><![CDATA[<p>TypeScript is a language from Microsoft which builds on JavaScript. This post is a non-technical overview of what
JavaScript is, how TypeScript extends JavaScript and why we choose to adopt TypeScript at Artsy.</p>

<!-- more -->


<a name="What.is.JavaScript."></a>
<h2>What is JavaScript?</h2>

<p>First up, you can't describe TypeScript without talking about JavaScript. To create a website (and a bunch of other
types of things) you work in three languages: HTML, CSS and JavaScript (JS). Broadly speaking: HTML defines the
content that will appear on the page, CSS defines the visual style of the page, and JS defines the interactive
behaviours of the page.</p>

<p>We describe having these sets of skills as being a "front-end" developer. You have to understand those three
languages to present anything inside a web browser like Safari, Firefox or Chrome. So, given how popular the web
is, there is a massive demand for people who are good at using these three languages.</p>

<p>There is also the set of skills for the "back-end" developers, which are to create computer services that
communicate either to a web browser (by passing it HTML/CSS/JS) or to another service (by sending a raw data.) You
don't need to use HTML, CSS or JS to write this type of code, but it's usually an end-product of your work. We
mostly build our back-ends in Ruby or JavaScript at Artsy.</p>

<a name="What.do.Programming.Languages.do."></a>
<h3>What do Programming Languages do?</h3>

<p>Programming languages are an interesting problem to solve. People read code many, many multiples of times more than
they write it - so developers create languages which are good at solving particular problems with a small amount of
code. Here's an example using JavaScript:</p>

<pre><code class="js">var name = "Danger"
console.log("Hello, " + name)
</code></pre>

<p>The first line makes a variable (a kind of box you can keep things in) and then the second line outputs text to the
console (think DOS, or the terminal) <code>"Hello, Danger"</code>. JavaScript is designed to work as a scripting language,
which means the code starts at the top of the file and then goes through line by line. To provide some contrast,
here is the <a href="https://repl.it/repls/VioletredGlisteningInfo">same behavior</a> in Java, which is built with different
language constraints:</p>

<pre><code class="java">class Main {
  public static void main(String[] args) {
    String name = "Danger";
    System.out.println("Hello, " + name);
  }
}
</code></pre>

<blockquote><p>Note: if you find the naming of Java and JavaScript confusing, it is (they are two completely separate
programming languages, no link at all.) JavaScript was <a href="https://medium.com/@benastontweet/lesson-1a-the-history-of-javascript-8c1ce3bffb17">named that way</a> because Java was looking to be
really the next hot language (it did turn out that way for a decade or two, but now JavaScript is usually the
first language people have heard of.)</p></blockquote>

<p>Aside from having a lot more lines, the Java version comes with a lot of words that aren't necessarily about
telling the computer exactly what to do, e.g. <code>class Main {</code>, <code>public static void main(String[] args) {</code>, <code>}</code> and
<code>}</code> again. It also has semi-colons at the end of some lines. Java is aimed at building different things from
JavaScript, and these extra bits of code make sense within the constraints of building a Java app.</p>

<p>To get to my main point though, there is one standout line I'd like us to compare:</p>

<pre><code>// JavaScript
var name = "Danger"
// Java
String name = "Danger";
</code></pre>

<p>Both of these lines declare variables called <code>name</code> which contain the value <code>"Danger"</code>.</p>

<p>In JavaScript you use the abbreviation <code>var</code> to declare a variable. Meanwhile, in Java you need to say <em>what kind
of data</em> the variable contains. In this case the variable contains a <code>String</code>. (A string is a programming term for
a collection of characters. They <code>"look like this"</code>. This <a href="https://www.youtube.com/watch?v=czTWbdwbt7E">5m video</a>
is a good primer if you want to learn more.)</p>

<p>Both of these variables contain a string, but the difference is that in Java the variable can <em>only</em> ever contain a
<em>string</em>, because that's what we said when we created the variable. In JS the variable can change to be <em>anything</em>,
like a number, or a list of dates.</p>

<p>To illustrate:</p>

<pre><code class="js">// Before in JS
var name = "Danger"
// Also OK
var name = 1
var name = false
var name = ["2018-02-03", "2019-01-12"]

// Before in Java
String name = "Danger";
// Not OK, the code wouldn't be accepted by Java
String name = 1;
String name = false
String name = new String[]{"2018-02-03", "2019-01-12"};
</code></pre>

<p>These trade-offs make sense in the context for which these languages were built back in 1995. JavaScript was
originally designed to be a small programming language which handled simple interactions on websites. Java on the
other hand was built specifically to make big apps which could run on any computer. Their needs had different
scales, so the language required programmers write different types of code.</p>

<p>Java required programmers to be more explicit with the values of their variables because the programs they expected
people to build were more complex. While JavaScript opted for ease of reading, and aimed to do less.</p>

<a name="What.is.TypeScript."></a>
<h3>What is TypeScript?</h3>

<p>TypeScript is a programming language - it contains all of JavaScript, and then a bit more. Using our example above,
let's compare the scripts for "Hello, Danger" in JavaScript vs TypeScript:</p>

<pre><code class="js">// JavaScript
var name = "Danger"
console.log("Hello, " + name)

// TypeScript
var name = "Danger"
console.log("Hello, " + name)

// Yep, you're not missing something, there's no difference
</code></pre>

<p>Due to TypeScript's aim to only <em>extend</em> JavaScript, your normal JavaScript code should work fine with TypeScript.
The things TypeScript adds to JavaScript are intended to help you be more explicit about what kinds of data are
used in your code, a bit like Java.</p>

<pre><code class="diff">- var name = "Danger"
+ var name: string = "Danger"
console.log("Hello, " + danger)
</code></pre>

<p>This extra <code>: string</code> allow the reader to be certain that <code>name</code> will only be a string. Annotating your variables
also gives TypeScript the chance to verify this for you. This is <em>very</em> useful because keeping track of changes
like the type of value in a variable seems easy when it's one or two, but once it starts hitting the hundreds,
that's a lot to keep track of. Types help programmers be more confident about their code because types catch
mistakes.</p>

<p>Simply speaking, we call these annotations "Types". Hence the name <i>Type</i>Script. The tag-line for TypeScript
is "JavaScript which scales" which is a statement that these extra type annotations allows you to work on bigger
projects. This is because you can verify up-front how correct your code is. This means you have less need to
understand how every change affects the rest of the program.</p>

<p>In the 90s, and maybe until a 5-10 years ago the trade-off for not having types in your JavaScript application was
fine because the size and complexities of the programs being built were constrained to just the front-end of
websites. Today though, JavaScript is being used everywhere:</p>

<ul>
<li>Apps like Slack, or Spotify for your computer are built in mostly JavaScript</li>
<li>Some iOS apps, including Artsy's are mostly JavaScript</li>
<li>The back-end and front-end of Artsy.net are JavaScript</li>
</ul>


<p>These are all considerably more complicated to build and understand, adding types drastically reduces the
complexity of making improvements to those programs.</p>

<a name="Why.does.Artsy.use.TypeScript."></a>
<h3>Why does Artsy use TypeScript?</h3>

<p>Artsy definitely isn't the size of Microsoft! Artsy is about 30 engineers, and Microsoft are about 60,000. However,
some of our problems are the same. Developers at Artsy build apps which are made up of thousands of files. A change
to one individual file can affect the behaviour of any number of other files, like throwing a pebble into a pond
and causing ripples to spread out to the bank.</p>

<p>Typically, the need to ensure there are no bugs is less of a problem for people building websites. Websites are
easy to make changes to, because if you change the site - everyone gets the update instantly. We also build our iOS
app with JavaScript, but a change to our app requires Apple to review the changes and for users to download the new
version from the App Store.</p>

<p>This means that the iOS team needs to have more checks that everything is OK before shipping the app to the world.
Using TypeScript gives our team the ability to feel good that the changes we have made are only the changes we
want.</p>

<p>TypeScript isn't the only programming language to tackle the problem of making JavaScript code safer, but it's the
one with the biggest community, allows people to re-use their JavaScript knowledge, can be added in small steps,
and has really good tools to help developers work faster.</p>

<p>These qualities made it worth adding an extra tool to our developers' toolbelt, and we're not the only ones because
TypeScript is growing to be <a href="https://www.wired.com/story/typescript-microsoft-javascript-alternative-most-popular">one of the most popular programming languages in the world</a> with almost 6
million downloads a week.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From TSLint to ESLint, or How I Learned to Lint GraphQL Code]]></title>
    <link href="https://artsy.github.io/blog/2019/01/29/from-tslint-to-eslint/"/>
    <updated>2019-01-29T00:00:00+01:00</updated>
    <id>https://artsy.github.io/blog/2019/01/29/from-tslint-to-eslint</id>
    <content type="html"><![CDATA[<p>At the beginning of January we discovered an interesting note in <a href="https://github.com/Microsoft/TypeScript/issues/29288">TypeScript's roadmap</a> about linting:</p>

<blockquote><p>In a survey we ran in VS Code a few months back, the most frequent theme we heard from users was that the linting
experience left much to be desired. Since part of our team is dedicated to editing experiences in JavaScript, our
editor team set out to add support for both TSLint and ESLint. However, we noticed that there were a few
architectural issues with the way TSLint rules operate that impacted performance. Fixing TSLint to operate more
efficiently would require a different API which would break existing rules (unless an interop API was built like
what wotan provides).</p>

<p>Meanwhile, ESLint already has the more-performant architecture we're looking for from a linter. Additionally,
different communities of users often have lint rules (e.g. rules for React Hooks or Vue) that are built for
ESLint, but not TSLint.</p>

<p>Given this, our editor team will be focusing on leveraging ESLint rather than duplicating work. For scenarios
that ESLint currently doesn't cover (e.g. semantic linting or program-wide linting), we'll be working on sending
contributions to bring ESLint's TypeScript support to parity with TSLint. As an initial testbed of how this works
in practice, we'll be switching the TypeScript repository over to using ESLint, and sending any new rules
upstream.</p></blockquote>

<p>At Artsy we've been using TSLint for a few years now; it's worked well for us, and we've even written our own
<a href="https://github.com/relay-tools/tslint-plugin-relay">custom rules</a>. However, given the vastness of the JS ecosystem
and how fast it moves, it's easy to recognize this announcement as an exciting moment for tooling simplicity.</p>

<!-- more -->


<p>To give an example, anyone who has built a culture around Airbnb's
<a href="https://github.com/airbnb/javascript">JavaScript style guide</a> will instantly recognize the conundrum they're in
when migrating to TypeScript:</p>

<p><img width="100%" alt="a reddit user discovers their linting rules no longer work" src="https://user-images.githubusercontent.com/236943/51884369-d845b380-233b-11e9-9d2f-102cc8a3a78b.png"></p>

<p>This means that teams maintaining legacy JavaScript codebases will no longer have to <em>also</em> maintain
<a href="https://github.com/palantir/tslint-react">two</a> <a href="https://github.com/yannickcr/eslint-plugin-react">versions</a> of often nearly <a href="https://github.com/prettier/tslint-plugin-prettier">identical</a>
<a href="https://github.com/prettier/prettier-eslint">rule-sets</a>. All of the aggregate culture that builds up around linting can now be shared in a
forward and backward facing way, making the often-daunting process of migrating a codebase from JavaScript to
TypeScript a much easier sell.</p>

<p>With this in mind we wanted to give the new officially-sanctioned <a href="https://github.com/typescript-eslint/typescript-eslint">typescript-eslint</a> project a
spin and document our findings.</p>

<a name="Setup"></a>
<h3>Setup</h3>

<p>To get started, install the necessary dependencies:</p>

<pre><code class="sh">$ yarn install -D eslint typescript @typescript-eslint/eslint-plugin
</code></pre>

<p>Then create a new <code>.eslintrc.js</code> and add a bit of setup:</p>

<pre><code class="js">module.exports = {
  parser: "@typescript-eslint/parser",
  plugins: ["@typescript-eslint"],
  extends: ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  parserOptions: {
    ecmaVersion: 6,
    project: "./tsconfig.json",
    sourceType: "module"
  }
}
</code></pre>

<p>Note that <code>parserOptions.project</code> points to your <code>tsconfig.json</code> file:</p>

<pre><code class="json">{
  "compilerOptions": {}
}
</code></pre>

<p>Next, add a bit of TypeScript to a file</p>

<pre><code class="sh">$ echo "export const foo: any = 'bar'" &gt; index.ts
</code></pre>

<p>and run the linter:</p>

<pre><code class="sh">$ yarn eslint . --ext .ts,.tsx

~/index.ts
  1:12  warning  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

✖ 1 problem (0 errors, 1 warnings)
</code></pre>

<p>Very nice!</p>

<p>Now lets expand the example a bit and add something more sophisticated, which in Artsy's use-case is commonly
GraphQL:</p>

<pre><code class="sh">$ yarn add -D eslint-plugin-graphql graphql-tag apollo
</code></pre>

<p>Update <code>tsconfig.json</code> and let it know we'll be using <code>node</code> for imports:</p>

<pre><code class="json">{
  "compilerOptions": {
    "moduleResolution": "node"
  }
}
</code></pre>

<p>In <code>.eslintrc.js</code> add these rules (while noting the addition of <code>graphql</code> to <code>plugins</code> and
<code>graphql/template-strings</code> under <code>rules</code>):</p>

<pre><code class="js">const path = require("path")

module.exports = {
  parser: "@typescript-eslint/parser",
  plugins: ["@typescript-eslint", "graphql"],
  extends: ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  parserOptions: {
    ecmaVersion: 6,
    project: "./tsconfig.json",
    sourceType: "module"
  },
  rules: {
    "graphql/template-strings": [
      "error",
      {
        schemaJsonFilepath: path.resolve(__dirname, "./schema.json"),
        tagName: "graphql"
      }
    ]
  }
}
</code></pre>

<p>For GraphQL to know what to lint, we'll need a schema. Thankfully the
<a href="https://etmdb.com/graphql">Ethiopian Movie Database</a> has our back :)</p>

<pre><code class="sh">$ yarn apollo service:download --endpoint https://etmdb.com/graphql
  ✔ Loading Apollo Project
  ✔ Saving schema to schema.json
✨  Done in 2.18s.
</code></pre>

<p>Back in <code>index.ts</code>, add this bit of code:</p>

<pre><code class="js">import graphql from "graphql-tag"

export const MovieQuery = graphql`
  query MoveQuery {
    allCinemaDetails(before: "2017-10-04", after: "2010-01-01") {
      edges {
        nodez {
          slug
          hallName
        }
      }
    }
  }
`
</code></pre>

<p>And run the linter:</p>

<pre><code class="sh">$ yarn eslint . --ext .ts,.tsx

~/index.ts
  7:9  error  Cannot query field "nodez" on type "CinemaDetailNodeEdge". Did you mean "node"?  graphql/template-strings

✖ 1 problem (1 error, 0 warnings)
</code></pre>

<p>Ahh yes, I meant <a href="https://i.redd.it/tfugj4n3l6ez.png"><code>node</code></a>.</p>

<a name="Bonus:.VSCode.Integration"></a>
<h3>Bonus: VSCode Integration</h3>

<p>As developers, we like our tools to work for us, and in 2019 the tool that <em>seems</em> to do that best just happens to
be a brilliant open source product from Microsoft. There were a couple unexpected configuration issues when we were
setting this up, but thankfully they're easy fixes.</p>

<pre><code class="sh">$ mkdir .vscode &amp;&amp; touch .vscode/settings.json
</code></pre>

<p>Then add a couple settings:</p>

<pre><code class="json">{
  "editor.formatOnSave": true,
  "eslint.autoFixOnSave": true,
  "eslint.validate": [
    {
      "language": "javascript",
      "autoFix": true
    },
    {
      "language": "javascriptreact",
      "autoFix": true
    },
    {
      "language": "typescript",
      "autoFix": true
    },
    {
      "language": "typescriptreact",
      "autoFix": true
    }
  ],
  "tslint.enable": false
}
</code></pre>

<p>Format on save, fix on save, <em>autofix</em> on save, tell ESLint to recognize <code>.ts</code> (and <code>.tsx</code>, for the React folks)
then disable <code>tslint</code> so that <code>eslint</code> can do its thing:</p>

<p><img width="698" alt="eslint displaying graphql error in VSCode IDE" src="https://user-images.githubusercontent.com/236943/51884366-d380ff80-233b-11e9-8128-6c39e210dd31.png"></p>

<p>Now ESLint will show you right where your GraphQL error is from within VSCode. Pretty sweet.</p>

<p>Be sure to read <a href="https://eslint.org/blog/2019/01/future-typescript-eslint">The future of TypeScript on ESLint</a> for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Conditional types in TypeScript]]></title>
    <link href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/"/>
    <updated>2018-11-21T00:00:00+01:00</updated>
    <id>https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript</id>
    <content type="html"><![CDATA[<p>This year TypeScript gained a new feature that punches far above its weight.</p>

<blockquote><p>Working through our (enormous) backlog of unsorted TypeScript "Suggestions" and it's remarkable how many of them
are solved by conditional types.</p></blockquote>

<p>-- <a href="https://twitter.com/SeaRyanC/status/1029846761718702081">Ryan Cavanaugh</a>, TypeScript maintainer</p>

<p>Conditional types probably aren't something you'll write every day, but you might end up using them indirectly all
the time. That's because they're great for 'plumbing' or 'framework' code, for dealing with API boundaries and
other behind-the-scenes kinda stuff. So, dear reader, read on! It's always good to learn how the sausage is made.
Then you can make sausage of your own.</p>

<p>Typewurst! 🌭</p>

<!-- more -->


<p><em>Note: This is a straightforward adaptation of a 35-minute presentation given at
<a href="https://www.meetup.com/Futurice-London-Beer-Tech/events/255295412/">Futurice London's TypeScript Night meetup</a>,
and therefore provides more context than an ordinary blog post might. I hope a lot of that context is interesting
and useful even for seasoned TypeScript developers. If you'd prefer a no-frills experience, check out the
<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html">TypeScript 2.8 Release notes</a> .</em></p>

<a name="Your.first.conditional.type"></a>
<h2>Your first conditional type</h2>

<p>Here's some plain JavaScript</p>

<pre><code class="ts">function process(text) {
  return text &amp;&amp; text.replace(/f/g, "p")
}

process("foo").toUpperCase()
</code></pre>

<p>Reading the code, it's clear to a human that the <code>.toUpperCase()</code> method call is safe. We can tell that whenever a
string is passed in to <code>process</code>, a string will be returned.</p>

<p>But notice that we could also pass something like <code>null</code> into the function, in which case <code>null</code> would be returned.
Then calling <code>.toUpperCase()</code> on the result would be an error.</p>

<p>Let's add basic types to this function so we can let TypeScript worry about whether we are using it safely or not.</p>

<pre><code class="ts">function process(text: string | null): string | null {
  return text &amp;&amp; text.replace(/f/g, "p")
}
</code></pre>

<p>Seems sensible. What happens if we try to use it like before?</p>

<pre><code class="ts">//            ⌄ Type Error! :(
process("foo").toUpperCase()
</code></pre>

<p>TypeScript complains because it thinks that the result of <code>process("foo")</code> might be <code>null</code>, even though we clever
humans know that it won't be. It can't figure out the runtime semantics of the function on its own.</p>

<p>One way of helping TS understand the function better is to use 'overloading'. Overloading involves providing
multiple type signatures for a single function, and letting TypeScript figure out which one to use in any given
context.</p>

<pre><code class="ts">function process(text: null): null;
function process(text: string): string;
function process(text: any) {
  ...
}
</code></pre>

<p>Here we've said that if we pass a <code>string</code>, it returns a <code>string</code>, and if we pass <code>null</code>, it returns <code>null</code>. <em>(The
<code>any</code> type is ignored but still needs to be there for some reason</em> 🤷‍️<em>)</em></p>

<p>That works nicely:</p>

<pre><code class="ts">// All clear!
process("foo").toUpperCase()
//           ⌄ Type Error! :)
process(null).toUpperCase()
</code></pre>

<p>But there's another use case that doesn't work:</p>

<pre><code class="ts">declare const maybeFoo: string | null

//      ⌄ Type Error! :(
process(maybeFoo)
</code></pre>

<p>TypeScript won't let us pass something that is of type <code>string | null</code> because it's not smart enough to collapse
the overloaded signatures when that's possible. So we can either add yet another overload signature for the
<code>string | null</code> case, or we can be like <span style="white-space: nowrap; font-family: sans-serif;">(╯°□°)╯︵
┻━┻</span> and switch to using <strong>conditional types</strong>.</p>

<pre><code class="ts">function process&lt;T extends string | null&gt;(
  text: T
): T extends string ? string : null {
  ...
}
</code></pre>

<p>Here we've introduced a type variable <code>T</code> for the <code>text</code> parameter. We can then use <code>T</code> as part of a conditional
return type: <code>T extends string ? string : null</code>. You probably noticed that this looks just like a ternary
expression! Indeed, it's doing the same kind of thing, but within the type system at compile time.</p>

<p>And that takes care of all our use cases:</p>

<pre><code class="ts">typeof process("foo") // =&gt; string
typeof process(null) // =&gt; null
typeof process(maybeFoo) // =&gt; string | null
</code></pre>

<p>So that's what a conditional type is! A kind of ternary type expression. It always has this form:</p>

<pre><code>A extends B ? C : D
</code></pre>

<p><code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> can be any old type expressions, but all the important stuff is happening on the left there.
In the <code>A extends B</code> condition.</p>

<a name="Assignability"></a>
<h2>Assignability</h2>

<p>This <code>extends</code> keyword is the heart of a conditional type. <code>A extends B</code> means precisely that any value of type <code>A</code>
can safely be assigned to a variable of type <code>B</code>. In type system jargon we can say that "A is <em>assignable</em> to B".</p>

<pre><code class="ts">declare const a: A
const b: B = a
// type check succeeds only if A is assignable to B
</code></pre>

<p>TypeScript decides which types are assignable to each other using an approach called 'structural typing'. This kind
of type system started appearing in mainstream languages relatively recently (in the last 10 years or so), and
might be a little counterintuitive if you come from a Java or C# background.</p>

<p>You may have heard of 'duck typing' in relation to dynamically-typed languages. The phrase 'duck typing' comes from
the proverb</p>

<blockquote><p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p></blockquote>

<p>In duck typing, you judge a thing by how it behaves, rather than what it is called or who its parents are. It's a
kind of meritocracy. Structural typing is a way of applying that same idea to a static compile-time type system.</p>

<p>So TypeScript only cares about what types can do, not what they are called or where they exist in a type hierarchy.</p>

<p>Take this simple example:</p>

<pre><code class="ts">class A {}
class B {}

const b: B = new A() // ✔ all good
const a: A = new B() // ✔ all good

new A() instanceof B // =&gt; false
</code></pre>

<p>TypeScript is happy treating two completely unrelated classes as equivalent because they have the same <em>structure</em>
and the same <em>capabilities</em>. Meanwhile, when checking the types at runtime, we discover that they are actually not
equivalent.</p>

<p>This is a notable example of where the semantics of TypeScript are at odds with JavaScript. It might seem like a
problem, but in practice structural typing is a lot more flexible than Java-esque 'nominal' typing, where names and
hierarchy matter. The two aren't mutually exclusive, however. Some languages, like Scala and Flow, allow you to mix
and match to suit particular problems.</p>

<p>Aside from that, the way that assignability works with structural typing is very intuitive.</p>

<pre><code class="ts">interface Shape {
  color: string
}

class Circle {
  color: string
  radius: number
}

// ✔ All good! Circles have a color
const shape: Shape = new Circle()
// ✘ Type error! Not all shapes have a radius!
const circle: Circle = shape
</code></pre>

<p>Speaking structurally we can say that <code>A extends B</code> is a lot like '<code>A</code> is a superset of <code>B</code>', or, to be more
verbose, '<code>A</code> has all of <code>B</code>'s properties, <em>and maybe some more</em>'.</p>

<p>There's one minor caveat though, and that's with 'literal' types. In TypeScript you can use literal values of
primitive types as types themselves.</p>

<pre><code class="ts">let fruit: "banana" = "banana"

// Type Error! "apple" is not assignable to "banana"
fruit = "apple"
</code></pre>

<p>The string <code>"banana"</code> doesn't have more properties than any other <code>string</code>. But the type <code>"banana"</code> is still more
<em>specific</em> than the type <code>string</code>.</p>

<p>So another way to think of <code>A extends B</code> is like '<code>A</code> is a possibly-more-specific version of <code>B</code>'.</p>

<p>Which brings us to 'top' and 'bottom' types: the <em>least</em> and <em>most</em> specific types, respectively.</p>

<p>In type theory a 'top' type is one which all other types are assignable to. It is the type you use to say "I have
absolutely no information about what this value is". Think of it as the union of all possible types:</p>

<pre><code class="ts">type Top = string | number | {foo: Bar} | Baz[] | ... | ∞
</code></pre>

<p>TypeScript has two top types: <code>any</code> and <code>unknown</code>.</p>

<ul>
<li>Using <code>any</code> is like saying "I have no idea what this value looks like. So, TypeScript, please assume I'm using it
correctly, and don't complain if anything I do seems dangerous".</li>
<li>Using <code>unknown</code> is like saying "I have no idea what this value looks like. So, TypeScript, please make sure I
check what it is capable of at run time."</li>
</ul>


<p>A 'bottom' type is one which no other types are assignable to, and that no values can be an instance of. Think of
it as the empty union type:</p>

<pre><code class="ts">type Bottom = ∅
</code></pre>

<p>TypeScript has one bottom type: <code>never</code>. That's a nice descriptive name because it literally means <em>this can never
happen</em>.</p>

<p>Top and bottom types are useful to know about when working with conditional types. <code>never</code> is especially useful
when using conditional types to refine unions...</p>

<a name="Refining.unions.with.distributive.conditional.types"></a>
<h2>Refining unions with distributive conditional types</h2>

<p>Conditional types let you filter out particular members of a union type. To illustrate, let's say we have a union
type called <code>Animal</code>:</p>

<pre><code class="ts">type Animal = Lion | Zebra | Tiger | Shark
</code></pre>

<p>And imagine that we needed to write a function that used only those animals which are also cats. We might write
some helper type called <code>ExtractCat</code> to do that:</p>

<pre><code class="ts">type ExtractCat&lt;A&gt; = A extends { meow(): void } ? A : never

type Cat = ExtractCat&lt;Animal&gt;
// =&gt; Lion | Tiger
</code></pre>

<p><em>I know lions and tigers don't meow, but how cute would it be if they did</em> ^_^</p>

<p>This seemed vague and magical to me at first. Let's see what TypeScript is doing under the hood when it evaluates
<code>ExtractCat&lt;Animal&gt;</code>.</p>

<p>First, it applies <code>ExtractCat</code> recursively to all the members of <code>Animal</code>:</p>

<!-- prettier-ignore -->


<pre><code class="ts">type Cat =
  | ExtractCat&lt;Lion&gt;
  | ExtractCat&lt;Zebra&gt;
  | ExtractCat&lt;Tiger&gt;
  | ExtractCat&lt;Shark&gt;
</code></pre>

<p>Then it evaluates the conditional types:</p>

<pre><code class="ts">type Cat = Lion | never | Tiger | never
</code></pre>

<p>And then something fun happens... Remember that no values can ever be of type <code>never</code>? That makes it totally
meaningless to include <code>never</code> in a union type, so TypeScript just gets rid of it.</p>

<pre><code class="ts">type Cat = Lion | Tiger
</code></pre>

<p>The TypeScript jargon for this kind of conditional type is <strong>distributive conditional type</strong>.</p>

<p>That 'distribution', where the union is unrolled recursively, only happens when the thing on the left of the
<code>extends</code> keyword is a plain type variable. We'll see what that means and how to work around it in the next
section.</p>

<a name="A.real.use-case.for.distributive.conditional.types."></a>
<h2>A real use-case for distributive conditional types.</h2>

<p>A while ago I was building a Chrome extension. It had a 'background' script and a 'view' script that ran in
different execution contexts. They needed to communicate and share state, and the only way to do that is via
serializable message passing. I took inspiration from Redux and defined a global union of interfaces called
<code>Action</code> to model the messages that I wanted to be able to pass between the contexts.</p>

<pre><code class="ts">type Action =
  | {
      type: "INIT"
    }
  | {
      type: "SYNC"
    }
  | {
      type: "LOG_IN"
      emailAddress: string
    }
  | {
      type: "LOG_IN_SUCCESS"
      accessToken: string
    }
// ...
</code></pre>

<p>And then there was a global <code>dispatch</code> function that I could use directly to broadcast messages across contexts</p>

<pre><code class="ts">declare function dispatch(action: Action): void

// ...

dispatch({
  type: "INIT"
})

// ...

dispatch({
  type: "LOG_IN",
  emailAddress: "david.sheldrick@artsy.net"
})

// ...

dispatch({
  type: "LOG_IN_SUCCESS",
  accessToken: "038fh239h923908h"
})
</code></pre>

<p><a
  target="_blank"
  style="font-size: 0.8em"
  href="https://www.typescriptlang.org/play/#src=type%20Action%20%3D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22INIT%22%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22SYNC%22%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22LOG_IN%22%0D%0A%20%20%20%20%20%20emailAddress%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22LOG_IN_SUCCESS%22%0D%0A%20%20%20%20%20%20accessToken%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%0D%0Adeclare%20function%20dispatch(action%3A%20Action)%3A%20void%0D%0A%0D%0Adispatch(%7B%0D%0A%20%20type%3A%20%22INIT%22%0D%0A%7D)%0D%0A%0D%0Adispatch(%7B%0D%0A%20%20type%3A%20%22LOG_IN%22%2C%0D%0A%20%20emailAddress%3A%20%22david.sheldrick%40artsy.net%22%0D%0A%7D)%0D%0A%0D%0Adispatch(%7B%0D%0A%20%20type%3A%20%22LOG_IN_SUCCESS%22%2C%0D%0A%20%20accessToken%3A%20%22038fh239h923908h%22%0D%0A%7D)">
<em>Try it in the TypeScript playground</em> </a></p>

<p>This API is typesafe and it plays well with my IDE's autocomplete and I could have left it there. I could have
moved on to other things.</p>

<p>But there's this little voice inside my head. I think most developers have this voice.</p>

<pre style="background: transparent; color: #333; border: 0; box-shadow: none; padding: 0;">
INT. HIPSTER CO-WORKING SPACE - DAY

DAVID sits on an oddly-shaped orange chair.
His MacBook rests askew on a lumpy reclaimed
wood desk. He stares at colorful text on a
dark screen.

A tiny whisper.

              VOICE (V.O.)
    Psst!

David looks around for a moment and then
stares back at the laptop.

              VOICE (V.O.)
    Psst! Hey!

Startled this time, David looks around
again. He speaks to nobody in particular.

              DAVID
    Is someone there?

              VOICE (V.O.)
    It's me, the DRY devil.

David heaves a painful sigh of recognition.

              DAVID
    Not you again! Leave me alone!

              DRY DEVIL (V.O.)
    DRY stands for "Don't Repeat Yourself"

              DAVID
    I know, you say that every time! Now
    get lost!

              DRY DEVIL (V.O.)
    I've noticed an issue with your code.

              DAVID
    Seriously, go away! I'm busy solving
    user problems to create business value.

              DRY DEVIL (V.O.)
    Every time you call `dispatch` you
    are typing 6 redundant characters.

              DAVID
    Oh snap! You're right! I must fix this.

MONTAGE

David spends the next 2 hours wrestling
with TypeScript, accumulating a pile of
empty coffee cups and protein ball wrappers.
</pre>


<p>We've all been there.</p>

<p>I wanted the dispatch function to work like this:</p>

<pre><code class="ts">// first argument is the 'type'
// second is any extra parameters
dispatch("LOG_IN_SUCCESS", {
  accessToken: "038fh239h923908h"
})
</code></pre>

<p>Deriving the type for that first argument is easy enough.</p>

<pre><code class="ts">type ActionType = Action["type"]
// =&gt; "INIT" | "SYNC" | "LOG_IN" | "LOG_IN_SUCCESS"
</code></pre>

<p>But the type of the second argument <em>depends on</em> the first argument. We can use a type variable to model that
dependency.</p>

<!-- prettier-ignore -->


<pre><code class="ts">declare function dispatch&lt;T extends ActionType&gt;(
  type: T,
  args: ExtractActionParameters&lt;Action, T&gt;
): void
</code></pre>

<p><em>Woah woah woah, what's this</em> <code>ExtractActionParameters</code> <em>voodoo?</em></p>

<p>It's a conditional type of course! Here's a first attempt at implementing it:</p>

<pre><code class="ts">type ExtractActionParameters&lt;A, T&gt; = A extends { type: T } ? A : never
</code></pre>

<p>This is a lot like the <code>ExtractCat</code> example from before, where we were were refining the <code>Animals</code> union by
searching for something that can <code>meow()</code>. Here, we're refining the <code>Action</code> union type by searching for an
interface with a particular <code>type</code> property. Let's see if it works:</p>

<pre><code class="ts">type Test = ExtractActionParameters&lt;Action, "LOG_IN"&gt;
// =&gt; { type: "LOG_IN", emailAddress: string }
</code></pre>

<p>Almost there! We don't want to keep the <code>type</code> field after extraction because then we would still have to specify
it when calling <code>dispatch</code>. And that would somewhat defeat the purpose of this entire exercise.</p>

<p>We can omit the <code>type</code> field by combining a <strong>mapped type</strong> with a conditional type and the <code>keyof</code> operator.</p>

<p>A <strong>mapped type</strong> lets you create a new interface by 'mapping' over a union of keys. You can get a union of keys
from an existing interface by using the <code>keyof</code> operator. And finally, you can remove things from a union using a
conditional type. Here's how they play together (with some inline test cases for illustration):</p>

<pre><code class="ts">type ExcludeTypeKey&lt;K&gt; = K extends "type" ? never : K

type Test = ExcludeTypeKey&lt;"emailAddress" | "type" | "foo"&gt;
// =&gt; "emailAddress" | "foo"

// here's the mapped type
type ExcludeTypeField&lt;A&gt; = { [K in ExcludeTypeKey&lt;keyof A&gt;]: A[K] }

type Test = ExcludeTypeField&lt;{ type: "LOG_IN"; emailAddress: string }&gt;
// =&gt; { emailAddress: string }
</code></pre>

<p>Then we can use <code>ExcludeTypeField</code> to redefine <code>ExtractActionParameters</code>.</p>

<!-- prettier-ignore -->


<pre><code class="ts">type ExtractActionParameters&lt;A, T&gt; = A extends { type: T }
  ? ExcludeTypeField&lt;A&gt;
  : never
</code></pre>

<p>And now the new version of <code>dipsatch</code> is typesafe!</p>

<pre><code class="ts">// All clear! :)
dispatch("LOG_IN_SUCCESS", {
  accessToken: "038fh239h923908h"
})

dispatch("LOG_IN_SUCCESS", {
  // Type Error! :)
  badKey: "038fh239h923908h"
})

// Type Error! :)
dispatch("BAD_TYPE", {
  accessToken: "038fh239h923908h"
})
</code></pre>

<p><a
  target="_blank"
  style="font-size: 0.8em"
  href="https://www.typescriptlang.org/play/#src=type%20Action%20%3D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22INIT%22%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22SYNC%22%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22LOG_IN%22%0D%0A%20%20%20%20%20%20emailAddress%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22LOG_IN_SUCCESS%22%0D%0A%20%20%20%20%20%20accessToken%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%0D%0Atype%20ActionType%20%3D%20Action%5B%22type%22%5D%0D%0A%0D%0Adeclare%20function%20dispatch%3CT%20extends%20ActionType%3E(%0D%0A%20%20%20%20type%3A%20T%2C%0D%0A%20%20%20%20args%3A%20ExtractActionParameters%3CAction%2C%20T%3E%0D%0A)%3A%20void%0D%0A%0D%0Atype%20ExcludeTypeKey%3CK%3E%20%3D%20K%20extends%20%22type%22%20%3F%20never%20%3A%20K%0D%0A%0D%0Atype%20ExcludeTypeField%3CA%3E%20%3D%20%7B%20%5BK%20in%20ExcludeTypeKey%3Ckeyof%20A%3E%5D%3A%20A%5BK%5D%20%7D%0D%0A%0D%0Atype%20ExtractActionParameters%3CA%2C%20T%3E%20%3D%20A%20extends%20%7B%20type%3A%20T%20%7D%0D%0A%20%20%20%20%3F%20ExcludeTypeField%3CA%3E%0D%0A%20%20%20%20%3A%20never%0D%0A%20%20%0D%0A%2F%2F%20All%20clear!%20%3A)%0D%0Adispatch(%22LOG_IN_SUCCESS%22%2C%20%7B%0D%0A%20%20%20%20accessToken%3A%20%22038fh239h923908h%22%0D%0A%7D)%0D%0A%0D%0Adispatch(%22LOG_IN_SUCCESS%22%2C%20%7B%0D%0A%20%20%20%20%2F%2F%20Type%20Error!%20%3A)%0D%0A%20%20%20%20badKey%3A%20%22038fh239h923908h%22%0D%0A%7D)%0D%0A%0D%0A%2F%2F%20Type%20Error!%20%3A)%0D%0Adispatch(%22BAD_TYPE%22%2C%20%7B%0D%0A%20%20%20%20accessToken%3A%20%22038fh239h923908h%22%0D%0A%7D)">
<em>Try it in the TypeScript playground</em> </a></p>

<p>But there's one more very serious problem to address: If the action has no extra parameters, I still have to pass a
second empty argument.</p>

<pre><code class="ts">dispatch("INIT", {})
</code></pre>

<p>That's four whole wasted characters! Cancel my meetings and tell my partner not to wait up tonight! We need to
<em>fix. this</em>.</p>

<p>The naïve thing to do would be to make the second argument optional. That would be unsafe because, e.g. it would
allow us to dispatch a <code>"LOG_IN"</code> action without specifying an <code>emailAddress</code>.</p>

<p>Instead, let's overload the <code>dispatch</code> function.</p>

<!-- prettier-ignore -->


<pre><code class="ts">// And let's say that any actions that don't require
// extra parameters are 'simple' actions.
declare function dispatch(type: SimpleActionType): void
// this signature is just like before
declare function dispatch&lt;T extends ActionType&gt;(
  type: T,
  args: ExtractActionParameters&lt;Action, T&gt;
): void

type SimpleActionType = ExtractSimpleAction&lt;Action&gt;['type']
</code></pre>

<p>How can we define this <code>ExtractSimpleAction</code> conditional type? We know that if we remove the <code>type</code> field from an
action and the result is an empty interface, then that is a simple action. So something like this might work</p>

<pre><code class="ts">type ExtractSimpleAction&lt;A&gt; = ExcludeTypeField&lt;A&gt; extends {} ? A : never
</code></pre>

<p>Except that doesn't work. <code>ExcludeTypeField&lt;A&gt; extends {}</code> is always going to be true, because <code>{}</code> is like a top
type for interfaces. <em>Pretty much everything</em> is more specific than <code>{}</code>.</p>

<p>We need to swap the arguments around:</p>

<pre><code class="ts">type ExtractSimpleAction&lt;A&gt; = {} extends ExcludeTypeField&lt;A&gt; ? A : never
</code></pre>

<p>Now if <code>ExcludeTypeField&lt;A&gt;</code> is empty, the condition will be true, otherwise it will be false.</p>

<p>But this still doesn't work! On-the-ball readers might remember this:</p>

<blockquote><p>That 'distribution', where the union is unrolled recursively, only happens when the thing on the left of the
<code>extends</code> keyword is a plain type variable. We'll see what that means and how to work around it in the next
section.</p></blockquote>

<p>-- Me, in the previous section</p>

<p>Type variables are always defined in a generic parameter list, delimited by <code>&lt;</code> and <code>&gt;</code>. e.g.</p>

<pre><code class="ts">type Blah&lt;These, Are, Type, Variables&gt; = ...

function blah&lt;And, So, Are, These&gt;() {
  ...
}
</code></pre>

<p>And if you want a conditional type to distribute over a union, the union a) needs to have been bound to a type
variable, and b) that variable needs to appear alone to the left of the <code>extends</code> keyword.</p>

<p>e.g. this is a distributive conditional type:</p>

<pre><code class="ts">type Blah&lt;Var&gt; = Var extends Whatever ? A : B
</code></pre>

<p>and these are not:</p>

<pre><code class="ts">type Blah&lt;Var&gt; = Foo&lt;Var&gt; extends Whatever ? A : B
type Blah&lt;Var&gt; = Whatever extends Var ? A : B
</code></pre>

<p>When I discovered this limitation I thought that it exposed a fundamental shortcoming in the way distributive
conditional types work under the hood. I thought it might be some kind of concession to algorithmic complexity. I
thought that my use case was too advanced, and that TypeScript had just thrown its hands up in the air and said,
"Sorry mate, you're on your own".</p>

<p>But it turns out I was wrong. It is just a pragmatic language design decision to avoid extra syntax, and you can
work around it easily:</p>

<!-- prettier-ignore -->


<pre><code class="ts">type ExtractSimpleAction&lt;A&gt; = A extends any
  ? {} extends ExcludeTypeField&lt;A&gt;
    ? A
    : never
  : never
</code></pre>

<p>All we did is wrap the meat of our logic in a flimsy tortilla of inevitability, since the outer condition
<code>A extends any</code> will, of course, always be true.</p>

<p>And finally we can delete those four characters 🎉🕺🏼💃🏽🎈</p>

<pre><code class="ts">dispatch("INIT")
</code></pre>

<p>That's one yak successfully shaved ✔</p>

<hr />

<p>TypeScript provides a couple of built-in types that we could have used in this section:</p>

<pre><code class="ts">// Exclude from U those types that are assignable to T
type Exclude&lt;U, T&gt; = U extends T ? never : U

// Extract from U those types that are assignable to T
type Extract&lt;U, T&gt; = U extends T ? U : never
</code></pre>

<p>e.g. instead of defining <code>ExcludeTypeField</code> like this:</p>

<pre><code class="ts">type ExcludeTypeField&lt;A&gt; = { [K in ExcludeTypeKey&lt;keyof A&gt;]: A[K] }
</code></pre>

<p>we could have done this:</p>

<pre><code class="ts">type ExcludeTypeField&lt;A&gt; = { [K in Exclude&lt;keyof A, "type"&gt;]: A[K] }
</code></pre>

<p>And instead of defining <code>ExtractActionParameters</code> like this:</p>

<!-- prettier-ignore -->


<pre><code class="ts">type ExtractActionParameters&lt;A, T&gt; = A extends { type: T }
  ? ExcludeTypeField&lt;A&gt;
  : never
</code></pre>

<p>we could have done this:</p>

<pre><code class="ts">type ExtractActionParameters&lt;A, T&gt; = ExcludeTypeField&lt;Extract&lt;A, { type: T }&gt;&gt;
</code></pre>

<a name="L.....Exercise.for.the.intrepid.reader"></a>
<h2>💡 Exercise for the intrepid reader</h2>

<p>Notice that this still works.</p>

<pre><code class="ts">dispatch("INIT", {})
</code></pre>

<p>Use what you've learned so far to make it an error to supply a second argument for 'simple' actions.</p>

<a name="Destructuring.types.with..code.infer..code."></a>
<h2>Destructuring types with <code>infer</code></h2>

<p>Conditional types have another trick up their sleeve: the <code>infer</code> keyword. It can be used anywhere in the type
expression to the right of the <code>extends</code> keyword. It gives a name to whichever type would appear in that place.
e.g.</p>

<pre><code class="ts">type Unpack&lt;A&gt; = A extends Array&lt;infer E&gt; ? E : A

type Test = Unpack&lt;Apple[]&gt;
// =&gt; Apple
type Test = Unpack&lt;Apple&gt;
// =&gt; Apple
</code></pre>

<p>It handles ambiguity gracefully:</p>

<pre><code class="ts">type Stairs = Unpack&lt;Apple[] | Pear[]&gt;
// =&gt; Apple | Pear
</code></pre>

<p>You can even use <code>infer</code> multiple times.</p>

<pre><code class="ts">type Flip&lt;T&gt; = T extends [infer A, infer B] ? [B, A] : never
type Stairs = Flip&lt;[Pear, Apple]&gt;
// =&gt; [Apple, Pear]

type Union&lt;T&gt; = T extends [infer A, infer A] ? A : never
type Stairs = Union&lt;[Apple, Pear]&gt;
// =&gt; Apple | Pear
</code></pre>

<a name="Other.built-in.conditional.types"></a>
<h2>Other built-in conditional types</h2>

<p>We've already seen <code>Exclude</code> and <code>Extract</code>, and TypeScript provides a few other conditional types out of the box.</p>

<!-- prettier-ignore -->


<pre><code class="ts">// Exclude null and undefined from T
type NonNullable&lt;T&gt; =
  T extends null | undefined ? never : T

// Obtain the parameters of a function type in a tuple
type Parameters&lt;T&gt; =
  T extends (...args: infer P) =&gt; any ? P : never

// Obtain the parameters of a constructor function type in a tuple
type ConstructorParameters&lt;T&gt; =
  T extends new (...args: infer P) =&gt; any ? P : never

// Obtain the return type of a function type
type ReturnType&lt;T&gt; =
  T extends (...args: any[]) =&gt; infer R ? R : any

// Obtain the return type of a constructor function type
type InstanceType&lt;T&gt; =
  T extends new (...args: any[]) =&gt; infer R ? R : any
</code></pre>

<a name="Further.reading"></a>
<h2>Further reading</h2>

<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html">TypeScript 2.8 release notes</a></li>
<li><a href="https://github.com/Microsoft/TypeScript/pull/21316">Microsoft/Typescript#21316</a> Conditional types pull request</li>
<li><a href="https://github.com/Microsoft/TypeScript/pull/21496">Microsoft/Typescript#21496</a> <code>infer</code> pull request</li>
<li><a href="https://github.com/Microsoft/TypeScript/blob/a2205ad53d8f65a129a552b752d1e06fee3d41fc/lib/lib.es5.d.ts#L1446">lib.es5.d.ts#L1446</a>
built-in conditional type definitions</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Announcing: Artsy x React Native]]></title>
    <link href="https://artsy.github.io/blog/2018/06/03/Announcing-Artsy-x-React-Native/"/>
    <updated>2018-06-03T00:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2018/06/03/Announcing-Artsy-x-React-Native</id>
    <content type="html"><![CDATA[<p>React Native has a lot of buzz around it. It is some serious and cool tech, yet can feel like a big departure from
your native iOS codebase. At Artsy, we like it. It has been the right choice for us. We've <a href="http://artsy.github.io/search/?q=react+native">documented</a> <a href="http://artsy.github.io/series/react-native-at-artsy/">our</a>
<a href="http://artsy.github.io/blog/2016/08/15/React-Native-at-Artsy/">journey</a> and <a href="http://artsy.github.io/blog/2018/03/17/two-years-of-react-native/">reasoning</a> quite extensively, but naturally, developers around the world are still wondering
whether the trade-offs make sense to <em>their</em> team, and <em>their</em> situation.</p>

<p>Enter <a href="https://www.artsy.net/x-react-native">Artsy x React-Native</a>.</p>

<p>Who better to partner with than Facebook? We're bringing a day full of hands-on informative insight and practical
play. With the focus on what building world class applications with RN can be like.</p>

<p>We'll demo, through talks and workshops, how to add React Native bit by bit to an existing codebase, set your
tooling up for success, and create solid animations.</p>

<p>We want <a href="https://www.artsy.net/x-react-native">Artsy x React-Native</a> to be about getting you up to speed with the framework, so you can make your
own decisions going forward.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScriptures 2 - TypeScript]]></title>
    <link href="https://artsy.github.io/blog/2018/05/02/JavaScriptures-2-TypeScript/"/>
    <updated>2018-05-02T00:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2018/05/02/JavaScriptures-2-TypeScript</id>
    <content type="html"><![CDATA[<p>The second in our JavaScriptures series on the Artsy <a href="http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">omakase</a>. This one is a deep dive in TypeScript with
a minor-focus on working with React. We run through a series of excercises you can run <a href="https://github.com/artsy/javascriptures/tree/master/2_intro-to-typescript">through yourself
here</a>.</p>

<p>It's ran by <a href="https://twitter.com/alloy">@alloy</a> and <a href="https://github.com/sarahscott">Sarah Scott</a> and covers compilation, errors, default types, interfaces,
inference, generics and how they all come together in your tools.</p>

<!-- more -->




<center>
<iframe width='100%' height='400' src='https://www.youtube.com/embed/KXPZvjCUlAA' frameborder='0' allowfullscreen></iframe>
</center>




<p style='text-align:right;'><a href="https://speakerdeck.com/artsyopensource/javascriptures-2-typescript">
Slides on Speakerdeck
</a></p>



]]></content>
  </entry>
  
</feed>
