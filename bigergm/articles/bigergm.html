<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>An Introduction to Estimating Exponential Random Graph Models for Large Networks with `bigergm` â€¢ bigergm</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="An Introduction to Estimating Exponential Random Graph Models for Large Networks with `bigergm`">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">bigergm</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.3</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/bigergm.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>An Introduction to Estimating Exponential Random Graph Models for Large Networks with `bigergm`</h1>
            
      

      <div class="d-none name"><code>bigergm.Rmd</code></div>
    </div>

    
    
<p>This vignette briefly introduces how to use the R package
<code>bigergm</code>, which estimates Hierarchical Exponential-Family
Random Graph Models <span class="citation">(HERGMs, Schweinberger and
Handcock 2015)</span>. The package <code>bigergm</code> builds on the R
packages <code>lighthergm</code> <span class="citation">(MartÃ­nez
Dahbura et al. 2021)</span> and <code>hergm</code> <span class="citation">(Schweinberger and Luna 2018)</span> and applies
scalable algorithms to scale the estimation up to big networks with up
to 50 K population members (see <span class="citation">MartÃ­nez Dahbura
et al. (2021)</span> and <span class="citation">Fritz et al.
(2024)</span>).</p>
<div class="section level2">
<h2 id="exponential-random-graph-models-for-large-networks">Exponential Random Graph Models for Large Networks<a class="anchor" aria-label="anchor" href="#exponential-random-graph-models-for-large-networks"></a>
</h2>
<p>Exponential Random Graph Models (ERGMs) are a popular class of models
for network data. They model the probability of observing a network as a
function of network statistics, such as the number of edges and
triangles. ERGMs are commonly employed in social network analysis but
have some limitations when applied to large networks. The main
limitation is that the likelihood function is intractable for large
networks, making it difficult to estimate the model parameters. At the
same time, larger networks warrant more complex models to capture the
underlying structure of the network.</p>
<p>To address these limitations, <code>bigergm</code> implements a
scalable algorithm for estimating HERGMs, which generalize ERGMs that
allow for local dependence induced by non-overlapping blocks of nodes
with network data. Introduced by <span class="citation">Schweinberger
and Handcock (2015)</span>, complex dependence is allowed only between
nodes within the same block. Thereby, we obtain a more flexible model
that can capture the cohesive subgroups in the network globally while
accounting for dependence within these subgroups on the local level.</p>
<div class="section level3">
<h3 id="model-specification">Model Specification<a class="anchor" aria-label="anchor" href="#model-specification"></a>
</h3>
<p>Consider a network of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
population members encompassed in the set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>N</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{P} = \{1, \ldots, N\}</annotation></semantics></math>.
Define the adjacency matrix corresponding to this network as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ˜</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆˆ</mo><msup><mi>â„</mi><mrow><mi>N</mi><mo>Ã—</mo><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{Y}= (Y_{i,j}) \in \mathbb{R}^{N\times N}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{i,j}</annotation></semantics></math>
is the entry in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
row and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>-th
column of the matrix. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Y_{i,j} = 1</annotation></semantics></math>,
nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
are connected; otherwise, they are not connected. In this vignette we
only regard undirected networks, thus the adjacency matrix is symmetric,
i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>Y</mi><mrow><mi>j</mi><mo>,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Y_{i,j} = Y_{j, i}</annotation></semantics></math>.<br>
Note, however, that the package <code>bigergm</code> also supports
directed networks. The number of blocks is denoted as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ³</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>z</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆˆ</mo><msup><mi>â„</mi><mrow><mi>N</mi><mo>Ã—</mo><mi>K</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{z}= (z_{i,k}) \in \mathbb{R}^{N\times K}</annotation></semantics></math>
is the block membership matrix with entries
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>z</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">z_{i,k}</annotation></semantics></math>
equal to 1 if node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
belongs to block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and 0 otherwise. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ˜</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf{Y}_{k,l}</annotation></semantics></math>
be the submatrix of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ˜</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>
of the connections between blocks
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>l</mi><annotation encoding="application/x-tex">l</annotation></semantics></math>,
i.e., the matrix including the connections between population members
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>âˆˆ</mo><mi>ğ’«</mi></mrow><annotation encoding="application/x-tex">j \in \mathcal{P}</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">z_{i,k} = z_{j,l}= 1</annotation></semantics></math>.
The submatrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ˜</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf{Y}_{k,k}</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ˜</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>
contains the connections within block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>,
i.e., the matrix including the connections between population members
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>âˆˆ</mo><mi>ğ’«</mi></mrow><annotation encoding="application/x-tex">j \in \mathcal{P}</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">z_{i,k} = z_{j,k}= 1</annotation></semantics></math>.
Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ±</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mi>p</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆˆ</mo><msup><mi>â„</mi><mrow><mi>N</mi><mo>Ã—</mo><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{x} = (x_{i,p}) \in \mathbb{R}^{N\times p}</annotation></semantics></math>
be a matrix of nodal covariates, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
is the number of covariates and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mi>p</mi></mrow></msub><annotation encoding="application/x-tex">x_{i,p}</annotation></semantics></math>
refers to the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>th
nodal covariate of population member
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
For the context of <code>bigergm</code>, assume that all nodal
covariates are categorical. Generally, we refer to random variables by
capitalized letters and their realizations by lowercase letters.</p>
<p>Given this notation, the probability of observing the network
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ˜</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>
for a given the block membership matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ™</mi><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math>
is given by:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ</mi><mi>Î¸</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ˜</mi><mo>=</mo><mi>ğ²</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo>,</mo><mi>ğ—</mi><mo>=</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>âˆ</mo><mrow><mi>k</mi><mo>â‰ </mo><mi>l</mi></mrow></munder><msub><mi>ğ</mi><mi>Î±</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ˜</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo>,</mo><mi>ğ—</mi><mo>=</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><munder><mo>âˆ</mo><mi>k</mi></munder><msub><mi>ğ</mi><mi>Î²</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ˜</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo>,</mo><mi>ğ—</mi><mo>=</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{P}_\theta(\mathbf{Y} = \mathbf{y} | \mathbf{Z} = \mathbf{z},\mathbf{X} = \mathbf{x}) = \prod_{k \neq l} \mathbf{P}_{\alpha}(\mathbf{Y}_{k,l} | \mathbf{Z} = \mathbf{z}, \mathbf{X} = \mathbf{x}) \prod_{k} \mathbf{P}_{\beta}(\mathbf{Y}_{k,k} | \mathbf{Z} = \mathbf{z}, \mathbf{X} = \mathbf{x}),
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ</mi><mi>Î±</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ˜</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{P}_{\alpha}(\mathbf{Y}_{k,l} | \mathbf{Z} = \mathbf{z})</annotation></semantics></math>
is the probability of observing the edges between blocks
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>l</mi><annotation encoding="application/x-tex">l</annotation></semantics></math>
given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ³</mi><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ</mi><mi>Î²</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ˜</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{P}_{\beta}(\mathbf{Y}_{k,k} | \mathbf{Z} = \mathbf{z})</annotation></semantics></math>
is the probability of observing the edges within block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ³</mi><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math>.
The parameter vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î²</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
are the coefficients of the between-block and within-block networks,
respectively. How these two models are specified is sketched in the next
two paragraphs.</p>
<div class="section level4">
<h4 id="between-block-model">Between-block Model<a class="anchor" aria-label="anchor" href="#between-block-model"></a>
</h4>
<p>For the probability model for edges between population members of
blocks
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>l</mi><annotation encoding="application/x-tex">l</annotation></semantics></math>,
we employ a network model assuming dyadic independence between the
edges:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ</mi><mi>Î±</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ˜</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>=</mo><msub><mi>ğ²</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo>,</mo><mi>ğ—</mi><mo>=</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>âˆ</mo><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mtext mathvariant="normal">; </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>z</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>=</mo><mn>1</mn><mrow><mtext mathvariant="normal">, </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>z</mi><mrow><mi>j</mi><mi>l</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow></munder><msub><mi>ğ</mi><mi>Î±</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo>,</mo><mi>ğ—</mi><mo>=</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{P}_{\alpha}(\mathbf{Y}_{k,l} = \mathbf{y}_{k,l} | \mathbf{Z} = \mathbf{z}, \mathbf{X} = \mathbf{x})  = \prod_{(i,j) \text{; } z_{ik} = 1 \text{, } z_{jl} = 1} \mathbf{P}_{\alpha}(Y_{i,j}  = y_{i,j} | \mathbf{Z} = \mathbf{z}, \mathbf{X} = \mathbf{x}), 
</annotation></semantics></math> where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ</mi><mi>Î±</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo>,</mo><mi>ğ—</mi><mo>=</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Ï€</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î±</mi><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>âˆ’</mo><msub><mi>Ï€</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î±</mi><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mo>âˆ’</mo><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></msup></mrow><annotation encoding="application/x-tex">
\mathbf{P}_{\alpha}(Y_{i,j} = y_{i,j} | \mathbf{Z} = \mathbf{z}, \mathbf{X} = \mathbf{x}) = (\pi_{k,l}(\alpha, \mathbf{x}))^{y_{i,j}} (1 - \pi_{k,l}(\alpha, \mathbf{x}))^{1 - y_{i,j}}
</annotation></semantics></math> is the probability distribution of a
Bernoulli distribution with parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î±</mi><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi_{k,l}(\alpha, \mathbf{x})</annotation></semantics></math>
evaluated at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">y_{i,j}</annotation></semantics></math>.<br>
The parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î±</mi><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi_{k,l}(\alpha, \mathbf{x})</annotation></semantics></math>
is the probability of observing an edge between nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">z_{i,k} = z_{j,l} = 1</annotation></semantics></math>
and have different forms:</p>
<ul>
<li>For the standard Stochastic Block Model (SBM), the probability of
observing an edge between nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î±</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><annotation encoding="application/x-tex">\alpha_{k,l}</annotation></semantics></math>.</li>
<li>Extending this simplistic model, the current implementation allows
the usage of <code>nodematch</code> statistics to include the nodal
covariates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\mathbf x</annotation></semantics></math>
in the model, implying the following probability for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">y_{i,j}</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">z_{i,k} = z_{j,l} = 1</annotation></semantics></math>:</li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î±</mi><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mtext mathvariant="normal">logit</mtext><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î±</mi><mo>+</mo><munderover><mo>âˆ‘</mo><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><mi>P</mi></munderover><msub><mi>Î±</mi><mi>p</mi></msub><mspace width="0.167em"></mspace><mi>ğ•€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mi>p</mi></mrow></msub><mo>=</mo><msub><mi>x</mi><mrow><mi>j</mi><mo>,</mo><mi>p</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\pi_{k,l}(\alpha, \mathbf{x}) = \text{logit}^{-1}\left(\alpha + \sum_{p = 1}^P \alpha_p \, \mathbb{I}\left(x_{i,p} = x_{j,p}\right) \right),
</annotation></semantics></math> where all parameters
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î±</mi><mi>p</mi></msub><annotation encoding="application/x-tex">\alpha_p</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">p = 1, \ldots, P</annotation></semantics></math>)
can vary for each pair of blocks
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>l</mi><annotation encoding="application/x-tex">l</annotation></semantics></math>.</p>
</div>
<div class="section level4">
<h4 id="within-block-model">Within-block Model<a class="anchor" aria-label="anchor" href="#within-block-model"></a>
</h4>
<p>The probability of observing the edges within block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is modeled as a function of network statistics, such as the number of
edges or triangles within block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>.
We specify the within-block networks as exponential-family random graph
models:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ</mi><mi>Î²</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ˜</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>ğ²</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mi>ğ™</mi><mo>=</mo><mi>ğ³</mi><mo>,</mo><mi>ğ—</mi><mo>=</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Î²</mi><mi>âŠ¤</mi></msup><mi>ğ¬</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ²</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î²</mi><mo>,</mo><mi>ğ³</mi><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{P}_{\beta}(\mathbf{Y}_{k,k} = \mathbf{y}_{k,k} | \mathbf{Z} = \mathbf{z}, \mathbf{X} = \mathbf{x}) = \exp\left(\beta^\top \mathbf{s}(\mathbf{y}_{k,k}, \mathbf{x})\right)/ c(\beta, \mathbf{z}, \mathbf{x}),
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ¬</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ²</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{s}(\mathbf{y}_{k,k}, \mathbf{x})</annotation></semantics></math>
is a vector of sufficient statistics counting, e.g., the edges within
block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î²</mi><mo>,</mo><mi>ğ³</mi><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c(\beta, \mathbf{z}, \mathbf{x})</annotation></semantics></math>
is a normalizing constant guaranteeing that the probability distribution
sums to one. Examples of network statistics include the number of edges,
triangles, and degree statistics (see <span class="citation">Morris,
Handcock, and Hunter (2008)</span> and all references therein).</p>
</div>
</div>
<div class="section level3">
<h3 id="estimation">Estimation<a class="anchor" aria-label="anchor" href="#estimation"></a>
</h3>
<p>Since the block membership matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ³</mi><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math>
is usually unobserved, we estimate it. Therefore, we assume that the now
random block membership matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ™</mi><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math>
is a latent variable and following a multinomial distribution:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ™</mi><mo>âˆ¼</mo><mtext mathvariant="normal">Multinomial</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>;</mo><msub><mi>Î³</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>Î³</mi><mi>K</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{Z} \sim \text{Multinomial}(1; \gamma_1, \ldots, \gamma_K),
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î³</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\gamma_k</annotation></semantics></math>
is the marginal probability that a node belongs to block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">k = 1, \ldots, K</annotation></semantics></math>.
Given this context, the model is estimated in two steps by the algorithm
proposed by <span class="citation">Babkin, Stewart, and Schweinberger
(2020)</span>:</p>
<ol style="list-style-type: decimal">
<li>Recover the block membership matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ™</mi><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math>
by maximizing a lower bound of the likelihood from the observed network
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ˜</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>
(see <span class="citation">Babkin, Stewart, and Schweinberger
(2020)</span> and <span class="citation">Vu, Hunter, and Schweinberger
(2013)</span> for details).</li>
<li>Given the estimated block membership matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>ğ™</mi><mo accent="true">Ì‚</mo></mover><annotation encoding="application/x-tex">\hat{\mathbf{Z}}</annotation></semantics></math>,
estimate the coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î²</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
by maximizing the pseudo-likelihood of the observed network
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ˜</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>.
The pseudo-likelihood of the observed network
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ˜</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>
given the estimated block membership matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>ğ™</mi><mo accent="true">Ì‚</mo></mover><annotation encoding="application/x-tex">\hat{\mathbf{Z}}</annotation></semantics></math>
is equivalent to the likelihood of a logistic regression model and can,
therefore, be estimated by standard optimization algorithms. For this
step, the entire computational machinery implemented in the
<code>ergm</code> package is used.</li>
</ol>
<p>However, note that the first step is unnecessary if the block
membership matrix is known.</p>
<p>The package <code>bigergm</code> implements a scalable algorithm for
estimating HERGMs even for large networks by exploiting the structure of
the model and the network data (details are provided in <span class="citation">MartÃ­nez Dahbura et al. (2021)</span> and <span class="citation">Fritz et al. (2024)</span>).</p>
</div>
</div>
<div class="section level2">
<h2 id="installation">Installation<a class="anchor" aria-label="anchor" href="#installation"></a>
</h2>
<p>You can install the CRAN version of <code>bigergm</code> by running
the following command:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html" class="external-link">install.packages</a></span><span class="op">(</span><span class="st">"bigergm"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="a-simple-example">A simple example<a class="anchor" aria-label="anchor" href="#a-simple-example"></a>
</h2>
<p>Letâ€™s start with a simple example using the toy network included in
the package. The toy network is a small network with a clear community
structure, which is helpful for testing the package.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Load the network object.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">toyNet</span><span class="op">)</span></span>
<span><span class="co"># Plot the network.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">toyNet</span>, vertex.col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"tomato"</span>, <span class="st">"steelblue"</span>, <span class="st">"darkgreen"</span>, <span class="st">"black"</span><span class="op">)</span>,</span>
<span>                        each <span class="op">=</span> <span class="va">toyNet</span><span class="op">$</span><span class="va">gal</span><span class="op">$</span><span class="va">n</span><span class="op">/</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-3-1.png" width="100%"></p>
<p>It is visible that this network has a cluster or community structure.
Although this is an artificial network, we often observe such community
structures in real-world social networks. Exploiting this stylized fact,
we model the way population members in a network get connected
differently for connections across and within communities:</p>
<ul>
<li>Connections across communities happen by luck, influenced by
homophily</li>
<li>Connections within communities also consider interdependencies among
links. For example, the probability that population members
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
get connected may be influenced by a third population member
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>.</li>
</ul>
<p>To estimate an Exponential Random Graph model with local dependence,
we first need to specify the model formula that specifies the model. As
described in the previous section, the model consists of two parts: the
between-block model and the within-block model. To ease this step, both
parts are specified in one formula very similar to specifying a model in
<code><a href="https://rdrr.io/pkg/ergm/man/ergm.html" class="external-link">ergm::ergm()</a></code>. All terms that induce dependence are excluded
from the between block model, while the within block model includes all
terms. In the following example, we include the number of edges, the
number of triangles, and nodematch statistics for the nodal covariates
<code>x</code> and <code>y</code> in the model.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model_formula</span> <span class="op">&lt;-</span> <span class="va">toyNet</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="fu">nodematch</span><span class="op">(</span><span class="st">"x"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">nodematch</span><span class="op">(</span><span class="st">"y"</span><span class="op">)</span> <span class="op">+</span> <span class="va">triangle</span></span></code></pre></div>
<p>Assuming that covariate â€˜xâ€™ is the first and covariate â€˜yâ€™ is the
second covariate, the probability of observing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{i,j}</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">z_{i,k} = z_{j,l} = 1</annotation></semantics></math>
is specified by:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î±</mi><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mtext mathvariant="normal">logit</mtext><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î±</mi><mn>0</mn></msub><mo>+</mo><msub><mi>Î±</mi><mn>2</mn></msub><mspace width="0.167em"></mspace><mi>ğ•€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>x</mi><mrow><mi>j</mi><mo>,</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Î±</mi><mn>2</mn></msub><mspace width="0.167em"></mspace><mi>ğ•€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>x</mi><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\pi_{k,l}(\alpha, \mathbf{x}) = \text{logit}^{-1}\left(\alpha_0 + \alpha_{2}\, \mathbb{I}(x_{i,1} = x_{j,1}) + \alpha_2\, \mathbb{I}(x_{i,2} = x_{j,2})\right)
</annotation></semantics></math> and the sufficient statistics of the
within-block model are:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ¬</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ²</mi><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>,</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>âˆ‘</mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></munder><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><munder><mo>âˆ‘</mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></munder><mi>ğ•€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mn>1</mn><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>x</mi><mrow><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><munder><mo>âˆ‘</mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></munder><mi>ğ•€</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mn>1</mn><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>x</mi><mrow><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><munder><mo>âˆ‘</mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></munder><munder><mo>âˆ‘</mo><mrow><mi>h</mi><mo>â‰ </mo><mi>i</mi><mo>,</mo><mi>j</mi></mrow></munder><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mspace width="0.167em"></mspace><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>h</mi></mrow></msub><mspace width="0.167em"></mspace><msub><mi>y</mi><mrow><mi>h</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathbf{s}(\mathbf{y}_{k,k}, \mathbf{x}) = \left(\sum_{i&lt;j} y_{i,j}, \sum_{i&lt;j} \mathbb{I}(x_{1,i} = x_{1,j})\, y_{i,j}, \sum_{i&lt;j} \mathbb{I}(x_{1,i} = x_{1,j})\, y_{i,j}, \sum_{i&lt;j}\sum_{h \neq i,j} y_{i,j}\, y_{i,h}\, y_{h,j}\right).
</annotation></semantics></math></p>
<p>We can estimate the specified model with the <code><a href="../reference/bigergm.html">bigergm()</a></code>
function, which takes the following parameters:</p>
<ul>
<li><p><code>object</code>: A formula specifying the model to estimate
(as detailed in the previous paragraph). See <code><a href="../reference/bigergm.html">help(bigergm)</a></code>
for how providing a fitted <code>bigergm</code> object can be used to
continue the estimation.</p></li>
<li><p><code>clustering_with_features</code>: boolean value set to TRUE,
if the algorithm should consider nodal covariates in the first step of
the estimation.</p></li>
<li><p><code>n_blocks</code>: Number of blocks to recover (in the above
explanations,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>).</p></li>
<li><p><code>n_MM_step_max</code>: Maximum number of MM algorithm
steps.</p></li>
<li><p><code>tol_MM_step</code>: Threshhold when convergence is reached.
Following <span class="citation">Vu, Hunter, and Schweinberger
(2013)</span>, we stop the algorithm when the relative change in the
lower bound of the objective function is less than
<code>tol_MM_step</code>.</p></li>
<li><p><code>estimate_parameters</code>: boolean value set to TRUE, if
the algorithm should estimate the parameters after the block recovery
step.</p></li>
<li><p><code>check_block_membership</code>: boolean value set to TRUE,
if the algorithm should keep track of block memberships at each MM
iteration.</p></li>
</ul>
<p>There are other parameters that you can specify, which are detailed
in the documentation (see <code><a href="../reference/bigergm.html">help(bigergm)</a></code>).</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res</span> <span class="op">&lt;-</span><span class="fu"><a href="../reference/bigergm.html">bigergm</a></span><span class="op">(</span></span>
<span>    <span class="co"># The model you would like to estimate</span></span>
<span>    object <span class="op">=</span> <span class="va">model_formula</span>,</span>
<span>    <span class="co"># The number of blocks</span></span>
<span>    n_blocks <span class="op">=</span>  <span class="fl">4</span>, </span>
<span>    <span class="co"># The maximum number of MM algorithm steps</span></span>
<span>    n_MM_step_max <span class="op">=</span> <span class="fl">100</span>,</span>
<span>    <span class="co"># The tolarence for the MM algorithm</span></span>
<span>    tol_MM_step <span class="op">=</span> <span class="fl">1e-6</span>,</span>
<span>    <span class="co"># Perform parameter estimation after the block recovery step</span></span>
<span>    estimate_parameters <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    <span class="co"># Indicate that clustering must take into account nodematch on characteristics</span></span>
<span>    clustering_with_features <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    <span class="co"># Keep track of block memberships at each EM iteration</span></span>
<span>    check_block_membership <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>    <span class="co"># Name the heuristic algorithm used for initializing the block memberships</span></span>
<span>    initialization <span class="op">=</span> <span class="st">"walktrap"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>We can plot the estimated the objective function of the first
estimation step recovering the latent community structure over
iterations. This allows us to check whether this step has converged.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">MM_lower_bound</span><span class="op">)</span>,</span>
<span>     <span class="va">res</span><span class="op">$</span><span class="va">MM_lower_bound</span>, type <span class="op">=</span> <span class="st">"l"</span>, xlab <span class="op">=</span> <span class="st">"Iterations"</span>, ylab <span class="op">=</span> <span class="st">"Lower Bound"</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-6-1.png" width="100%"></p>
<p>The result indicates that the clustering step converged at the early
stage. Note that the number of iterations you need to perform
(<code>n_MM_step_max</code>) varies depending on the networkâ€™s size and
clarity in community structure. The convergence of the lower bound does,
however, not guarantee the convergence of the clustering step to a
unique maximizer. Therefore, restarting the algorithm with different
initializations may be advisable in practice.</p>
<p>You can check the clustering result by plotting the network with
nodes colored by the estimated block membership. The edges are grey if
the two population members are from different blocks and black
otherwise.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-7-1.png" width="100%"></p>
<p>The parameter estimates of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î²</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
may be inspected using the <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> function.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># For the between networks</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">est_between</span><span class="op">)</span></span>
<span><span class="co">#&gt;  Results:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;             Estimate Std. Error MCMC % z value Pr(&gt;|z|)    </span></span>
<span><span class="co">#&gt; edges       -4.21749    0.07482      0 -56.369   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; nodematch.x  0.78273    0.16144      0   4.848   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; nodematch.y  0.38854    0.18433      0   2.108    0.035 *  </span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Warning:  The standard errors are based on naive pseudolikelihood and are suspect. Set control.ergm$MPLE.covariance.method='Godambe' for a simulation-based approximation of the standard errors.</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;      Null Pseudo-deviance: 2576  on 8  degrees of freedom</span></span>
<span><span class="co">#&gt;  Residual Pseudo-deviance: 2551  on 5  degrees of freedom</span></span>
<span><span class="co">#&gt;  </span></span>
<span><span class="co">#&gt; AIC: 2557  BIC: 2558  (Smaller is better. MC Std. Err. = NA)</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># For the within networks</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">est_within</span><span class="op">)</span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; ergm::ergm(formula = within_formula, offset.coef = offset.coef, </span></span>
<span><span class="co">#&gt;     estimate = method, control = control)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Maximum Pseudolikelihood Results:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;             Estimate Std. Error MCMC % z value Pr(&gt;|z|)    </span></span>
<span><span class="co">#&gt; edges       -1.80056    0.06660      0 -27.036   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; nodematch.x  0.86683    0.10351      0   8.375   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; nodematch.y  0.96478    0.10368      0   9.305   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; triangle     0.14615    0.01744      0   8.382   &lt;1e-04 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Warning:  The standard errors are based on naive pseudolikelihood and are suspect. Set control.ergm$MPLE.covariance.method='Godambe' for a simulation-based approximation of the standard errors.</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;      Null Pseudo-deviance: 6793  on 4900  degrees of freedom</span></span>
<span><span class="co">#&gt;  Residual Pseudo-deviance: 5154  on 4896  degrees of freedom</span></span>
<span><span class="co">#&gt;  </span></span>
<span><span class="co">#&gt; AIC: 5162  BIC: 5188  (Smaller is better. MC Std. Err. = 0)</span></span></code></pre></div>
<p>Currently, only <code>nodematch()</code> terms are supported as a way
to include covariates in the model.</p>
</div>
<div class="section level2">
<h2 id="simulation">Simulation<a class="anchor" aria-label="anchor" href="#simulation"></a>
</h2>
<p>You can simulate networks with local dependence by using
<code><a href="../reference/bigergm.html">bigergm ()</a></code> and <code><a href="../reference/simulate_bigergm.html">simulate_bigergm()</a></code> functions.
The <code><a href="../reference/simulate.bigergm.html">simulate.bigergm()</a></code> function is a wrapper around the
<code><a href="../reference/simulate_bigergm.html">simulate_bigergm()</a></code> function for a particular fitted
<code>bigergm</code> object. To apply the
<code><a href="../reference/simulate.bigergm.html">simulate.bigergm()</a></code> function, you only need to provide the
fitted <code>bigergm</code> object.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">res</span>, seed <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt;  Network attributes:</span></span>
<span><span class="co">#&gt;   vertices = 200 </span></span>
<span><span class="co">#&gt;   directed = FALSE </span></span>
<span><span class="co">#&gt;   hyper = FALSE </span></span>
<span><span class="co">#&gt;   loops = FALSE </span></span>
<span><span class="co">#&gt;   multiple = FALSE </span></span>
<span><span class="co">#&gt;   bipartite = FALSE </span></span>
<span><span class="co">#&gt;   total edges= 1464 </span></span>
<span><span class="co">#&gt;     missing edges= 0 </span></span>
<span><span class="co">#&gt;     non-missing edges= 1464 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  Vertex attribute names: </span></span>
<span><span class="co">#&gt;     block vertex.names x y </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  Edge attribute names not shown</span></span></code></pre></div>
<p>The <code><a href="../reference/simulate_bigergm.html">simulate_bigergm()</a></code> function allows you to simulate
networks with local dependence from scratch. The function requires
coefficients for the between and within connections, the formula for the
model, the number of simulations to return, and the output format.
Depending on the output format, the function returns a list with the
network statistics for the between and within connections, the adjacency
matrix of the simulated network, or the network object itself.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim_net</span> <span class="op">&lt;-</span> <span class="fu">bigergm</span><span class="fu">::</span><span class="fu"><a href="../reference/simulate_bigergm.html">simulate_bigergm</a></span><span class="op">(</span></span>
<span>  formula <span class="op">=</span> <span class="va">model_formula</span>,</span>
<span>  <span class="co"># The coefficients for the between connections</span></span>
<span>  coef_between <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">est_between</span><span class="op">$</span><span class="va">coefficients</span>,</span>
<span>   <span class="co"># The coefficients for the within connections</span></span>
<span>  coef_within <span class="op">=</span> <span class="va">res</span><span class="op">$</span><span class="va">est_within</span><span class="op">$</span><span class="va">coefficients</span>,</span>
<span>  <span class="co"># Number of simulations to return</span></span>
<span>  nsim <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  <span class="co"># If `stats` a list with network statistics </span></span>
<span>  <span class="co"># for the between and within connections is returned</span></span>
<span>  output <span class="op">=</span> <span class="st">"network"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>After simulating the network, you can plot it to assess whether the
community structure is preserved.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">sim_net</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-12-1.png" width="100%"></p>
</div>
<div class="section level2">
<h2 id="goodness-of-fit">Goodness-of-fit<a class="anchor" aria-label="anchor" href="#goodness-of-fit"></a>
</h2>
<p>Following the estimation, consider evaluating the goodness-of-fit of
the model. In line with the ERGM literature, we provide a
goodness-of-fit assessment that evaluates how good simulations from the
model fit the observed network. We provide a function <code>gof()</code>
to carry out this task:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">gof_res</span> <span class="op">&lt;-</span> <span class="fu">gof</span><span class="op">(</span></span>
<span>  <span class="co"># The object returned by bigergm::bigergm()</span></span>
<span>  object <span class="op">=</span> <span class="va">res</span>,</span>
<span>  <span class="co"># The number of simulations to use</span></span>
<span>  nsim <span class="op">=</span> <span class="fl">100</span>, </span>
<span>  <span class="co"># Compute the geodesic distance for the observed and each simulated network</span></span>
<span>  compute_geodesic_distance <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  <span class="co"># Set a seed for reproducibility</span></span>
<span>  seed <span class="op">=</span> <span class="fl">1234</span>,</span>
<span>  <span class="co"># Start at the observed network</span></span>
<span>  start_from_observed <span class="op">=</span> <span class="cn">TRUE</span>, type <span class="op">=</span> <span class="st">"within"</span>,</span>
<span>  <span class="co"># The control parameters for the simulation</span></span>
<span>  control_within <span class="op">=</span> <span class="fu">ergm</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/ergm/man/control.simulate.ergm.html" class="external-link">control.simulate.formula</a></span><span class="op">(</span>MCMC.burnin <span class="op">=</span> <span class="fl">1000</span>, MCMC.interval <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The parameter <code>control_within</code> is used to control the MCMC
simulation carried out to simulate from the model. For details we refer
to <code>help(ergm::control.simulate.formula)</code>. The function
evaluates the following metrics for a hundred simulated and observed
networks:</p>
<ol style="list-style-type: decimal">
<li><p>network statistics used in the fit or formula provided,</p></li>
<li><p>normalized network statistics (the network statistics normalized
around the observed statistics),</p></li>
<li><p>degree distribution,</p></li>
<li><p>geodesic distance, and</p></li>
<li><p>edgewise shared partners.</p></li>
</ol>
<p>The function <code>bigergm::gof_bigergm()</code> returns a list of
data frames for these matrices, allowing you to create plots that match
your needs flexibly. Below is an example plot for the degree
distribution on the log scale.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">degree_gof</span> <span class="op">&lt;-</span> </span>
<span>  <span class="va">gof_res</span><span class="op">$</span><span class="va">simulated</span><span class="op">$</span><span class="va">degree_dist</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html" class="external-link">group_by</a></span><span class="op">(</span><span class="va">degree</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html" class="external-link">summarise</a></span><span class="op">(</span>log_mean_share <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">share</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                   log_sd_share <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html" class="external-link">sd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">share</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html" class="external-link">ungroup</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">degree_gof</span><span class="op">$</span><span class="va">degree</span>, <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_mean_share</span>,</span>
<span>     xlab <span class="op">=</span> <span class="st">"Degree"</span>, ylab <span class="op">=</span> <span class="st">"Log Prop. of Nodes"</span>,</span>
<span>     ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">5.5</span>,<span class="op">-</span><span class="fl">1.8</span><span class="op">)</span>, xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">6</span>,<span class="fl">17</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"l"</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">degree_gof</span><span class="op">$</span><span class="va">degree</span>, <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_mean_share</span><span class="op">+</span> <span class="fl">1.96</span> <span class="op">*</span> <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_sd_share</span>, type <span class="op">=</span> <span class="st">"l"</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">degree_gof</span><span class="op">$</span><span class="va">degree</span>, <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_mean_share</span><span class="op">-</span> <span class="fl">1.96</span> <span class="op">*</span> <span class="va">degree_gof</span><span class="op">$</span><span class="va">log_sd_share</span>, type <span class="op">=</span> <span class="st">"l"</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">tmp_info</span> <span class="op">&lt;-</span> <span class="va">gof_res</span><span class="op">$</span><span class="va">original</span><span class="op">$</span><span class="va">degree_dist</span> <span class="op">%&gt;%</span> </span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">share</span> <span class="op">&gt;</span> <span class="fl">0</span> <span class="op">&amp;</span> <span class="va">degree</span> <span class="op">&lt;</span> <span class="fl">22</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">tmp_info</span><span class="op">$</span><span class="va">degree</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">tmp_info</span><span class="op">$</span><span class="va">share</span><span class="op">)</span>, lty <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-14-1.png" width="100%"></p>
<p>Alternatively, you can use the <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> function to
visualize the goodness-of-fit results. Three plots are generated
checking whether the estimated model can adequately capture the degree
distribution, edgewise-shared partner distribution, and geodesic
distances of the observed network. In a fourth plot, the simulated
network statistics are plotted normalized around the observed
statistics. For a good fit, all values should be around zero. In all
plots, the red line represents the observed network, and the boxplot
represents the simulated networks.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">gof_res</span><span class="op">)</span></span></code></pre></div>
<p><img src="bigergm_files/figure-html/unnamed-chunk-15-1.png" width="100%"><img src="bigergm_files/figure-html/unnamed-chunk-15-2.png" width="100%"><img src="bigergm_files/figure-html/unnamed-chunk-15-3.png" width="100%"><img src="bigergm_files/figure-html/unnamed-chunk-15-4.png" width="100%"></p>
</div>
<div class="section level2">
<h2 id="when-you-work-with-large-networks">When you work with large networks<a class="anchor" aria-label="anchor" href="#when-you-work-with-large-networks"></a>
</h2>
<p>If you would like to estimate an bigergm with a large network (say,
when the number of nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>â‰¥</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math>
50,000):</p>
<ul>
<li>Select features sparse enough to fit into memory. Covariates such as
gender or race will be too dense to construct feature matrices. This is
a non-negligible limitation of our algorithm and will be solved in the
future.</li>
<li>Use Pythonâ€™s infomap to initialize clusters. This is because it is
much faster to implement cluster initialization than R functions such as
<code><a href="https://r.igraph.org/reference/cluster_infomap.html" class="external-link">igraph::cluster_infomap()</a></code>. Set
<code>use_infomap_python = TRUE</code> in
<code><a href="../reference/bigergm.html">bigergm::bigergm()</a></code>.</li>
<li>When the MM estimation does not seem to have converged by inspecting
the lower bound plot, you can further continue iterating by passing the
<code>bigergm</code> class object to <code><a href="../reference/bigergm.html">bigergm::bigergm()</a></code> as
follows (all parameters such as the number of MM iterations will be
inherited from the previous estimation unless specified).</li>
<li>You can also set the parameter
<code>only_use_preprocessed = TRUE</code>, if you do not want to
preprocess it again and start the estimation again from a different
initial value.</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_second</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">bigergm</span><span class="fu">::</span><span class="fu"><a href="../reference/bigergm.html">bigergm</a></span><span class="op">(</span>object <span class="op">=</span> <span class="va">res</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-babkin_2020" class="csl-entry">
Babkin, Sergii, Jonathan Stewart, and Michael Schweinberger. 2020.
<span>â€œLarge-Scale Estimation of Random Graph Models with Local
Dependence.â€</span> <em>Computational Statistics &amp; Data
Analysis</em> 152: 107029.
</div>
<div id="ref-fritz2024" class="csl-entry">
Fritz, Cornelius, Co-Piere Georg, Angelo Mele, and Michael
Schweinberger. 2024. <span>â€œA Strategic Model of Software Dependency
Networks,â€</span> Working Paper. Available at
https://arxiv.org/abs/2402.13375.
</div>
<div id="ref-martinezdahbura2021" class="csl-entry">
MartÃ­nez Dahbura, Juan Nelson, Shota Komatsu, Takanori Nishida, and
Angelo Mele. 2021. <span>â€œA Structural Model of Business Card Exchange
Networks,â€</span> Working Paper. Available at
https://arxiv.org/abs/2105.12704.
</div>
<div id="ref-morris2008" class="csl-entry">
Morris, Martina, Mark S Handcock, and Dave Hunter. 2008.
<span>â€œSpecification of Exponential-Family Random Graph Models: Terms
and Computational Aspects.â€</span> <em>Journal of Statistical
Software</em> 24 (4).
</div>
<div id="ref-schweinberger2015" class="csl-entry">
Schweinberger, Michael, and Mark S Handcock. 2015. <span>â€œLocal
Dependence in Random Graph Models: Characterization, Properties and
Statistical Inference.â€</span> <em>Journal of the Royal Statistical
Society B</em> 77 (3): 647â€“76.
</div>
<div id="ref-schweinberger2018" class="csl-entry">
Schweinberger, Michael, and Pamela Luna. 2018. <span>â€œHergm:
Hierarchical Exponential-Family Random Graph Models.â€</span> <em>Journal
of Statistical Software</em> 85 (1): 1â€“39.
</div>
<div id="ref-vu_2013" class="csl-entry">
Vu, Duy, David Hunter, and Michael Schweinberger. 2013.
<span>â€œModel-Based Clustering of Large Networks.â€</span> <em>The Annals
of Applied Statistics</em> 7 (2): 1010â€“39.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Cornelius Fritz, Michael Schweinberger, Shota Komatsu, Juan Nelson MartÃ­nez Dahbura, Takanori Nishida, Angelo Mele.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
